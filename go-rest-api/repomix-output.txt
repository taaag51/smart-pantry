This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-01T10:10:39.331Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
controller/
  food_item_controller_test.go
  food_item_controller.go
  recipe_controller_test.go
  recipe_controller.go
  task_controller.go
  user_controller_test.go
  user_controller.go
db/
  db.go
migrate/
  migrate.go
model/
  food_item_changes.md
  food_item.go
  task.go
  user.go
repository/
  food_item_repository.go
  task_repositoty.go
  user_repository.go
router/
  router.go
services/
  gemini_service_test.go
  gemini_service.go
testutil/
  testutil.go
usecase/
  errors.go
  food_item_usecase.go
  recipe_usecase_test.go
  recipe_usecase.go
  task_usecase.go
  user_usecase_test.go
  user_usecase.go
validator/
  task_validator.go
  user_validator.go
.env.test
docker-compose.test.yml
docker-compose.yml
Dockerfile
go.mod
main.go

================================================================
Files
================================================================

================
File: controller/food_item_controller_test.go
================
package controller

import (
	"encoding/json"
	"errors"
	"go-rest-api/mock"
	"go-rest-api/model"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/golang/mock/gomock"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
)

func TestFoodItemController_GetAllFoodItems(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFoodItemUsecase := mock.NewMockIFoodItemUsecase(ctrl)
	foodItemController := NewFoodItemController(mockFoodItemUsecase)

	tests := []struct {
		name           string
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：食材一覧の取得成功",
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					GetAllFoodItems().
					Times(1).
					Return([]model.FoodItem{
						{
							ID:         1,
							Title:      "りんご",
							Quantity:   5,
							ExpiryDate: time.Now().Add(24 * time.Hour),
							UserId:     1,
							CreatedAt:  time.Now(),
							UpdatedAt:  time.Now(),
						},
					}, nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)

				foodItems, ok := response.Data.([]interface{})
				assert.True(t, ok)
				assert.Len(t, foodItems, 1)
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "異常系：内部エラー",
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					GetAllFoodItems().
					Times(1).
					Return(nil, errors.New("internal error"))
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusInternalServerError, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "internal error", response.Message)
			},
			expectedStatus: http.StatusInternalServerError,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodGet, "/api/food-items", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			tt.buildStubs()

			err := foodItemController.GetAllFoodItems(c)
			assert.NoError(t, err)

			tt.checkResponse(t, rec)
		})
	}
}

func TestFoodItemController_GetFoodItemById(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFoodItemUsecase := mock.NewMockIFoodItemUsecase(ctrl)
	foodItemController := NewFoodItemController(mockFoodItemUsecase)

	tests := []struct {
		name           string
		id             string
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：食材の取得成功",
			id:   "1",
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					GetFoodItemById(uint(1)).
					Times(1).
					Return(&model.FoodItem{
						ID:         1,
						Title:      "りんご",
						Quantity:   5,
						ExpiryDate: time.Now().Add(24 * time.Hour),
						UserId:     1,
						CreatedAt:  time.Now(),
						UpdatedAt:  time.Now(),
					}, nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)

				foodItem, ok := response.Data.(map[string]interface{})
				assert.True(t, ok)
				assert.Equal(t, float64(1), foodItem["id"])
				assert.Equal(t, "りんご", foodItem["title"])
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "異常系：不正なID",
			id:   "invalid",
			buildStubs: func() {
				// 不正なIDの場合はusecaseは呼ばれない
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusBadRequest, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Invalid ID format", response.Message)
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodGet, "/api/food-items/:id", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.SetParamNames("id")
			c.SetParamValues(tt.id)

			tt.buildStubs()

			err := foodItemController.GetFoodItemById(c)
			assert.NoError(t, err)

			tt.checkResponse(t, rec)
		})
	}
}

func TestFoodItemController_CreateFoodItem(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFoodItemUsecase := mock.NewMockIFoodItemUsecase(ctrl)
	foodItemController := NewFoodItemController(mockFoodItemUsecase)

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": float64(1),
	})

	tests := []struct {
		name           string
		body           string
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：食材の作成成功",
			body: `{"title":"りんご","quantity":5,"expiry_date":"2024-02-01T00:00:00Z"}`,
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					CreateFoodItem(gomock.Any()).
					Times(1).
					Return(&model.FoodItem{
						ID:         1,
						Title:      "りんご",
						Quantity:   5,
						ExpiryDate: time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC),
						UserId:     1,
						CreatedAt:  time.Now(),
						UpdatedAt:  time.Now(),
					}, nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusCreated, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Food item created successfully", response.Message)
			},
			expectedStatus: http.StatusCreated,
		},
		{
			name: "異常系：不正なリクエストボディ",
			body: `{"title": 123}`, // 不正な型
			buildStubs: func() {
				// 不正なボディの場合はusecaseは呼ばれない
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusBadRequest, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Invalid request format", response.Message)
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodPost, "/api/food-items", strings.NewReader(tt.body))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.Set("user", token)

			tt.buildStubs()

			err := foodItemController.CreateFoodItem(c)
			assert.NoError(t, err)

			tt.checkResponse(t, rec)
		})
	}
}

func TestFoodItemController_UpdateFoodItem(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFoodItemUsecase := mock.NewMockIFoodItemUsecase(ctrl)
	foodItemController := NewFoodItemController(mockFoodItemUsecase)

	tests := []struct {
		name           string
		id             string
		body           string
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：食材の更新成功",
			id:   "1",
			body: `{"title":"更新済みりんご","quantity":3,"expiry_date":"2024-02-01T00:00:00Z"}`,
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					UpdateFoodItem(gomock.Any()).
					Times(1).
					Return(nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Food item updated successfully", response.Message)
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "異常系：不正なID",
			id:   "invalid",
			body: `{"title":"りんご","quantity":5}`,
			buildStubs: func() {
				// 不正なIDの場合はusecaseは呼ばれない
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusBadRequest, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Invalid ID format", response.Message)
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodPut, "/api/food-items/:id", strings.NewReader(tt.body))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.SetParamNames("id")
			c.SetParamValues(tt.id)

			tt.buildStubs()

			err := foodItemController.UpdateFoodItem(c)
			assert.NoError(t, err)

			tt.checkResponse(t, rec)
		})
	}
}

func TestFoodItemController_DeleteFoodItem(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFoodItemUsecase := mock.NewMockIFoodItemUsecase(ctrl)
	foodItemController := NewFoodItemController(mockFoodItemUsecase)

	tests := []struct {
		name           string
		id             string
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：食材の削除成功",
			id:   "1",
			buildStubs: func() {
				mockFoodItemUsecase.EXPECT().
					DeleteFoodItem(uint(1)).
					Times(1).
					Return(nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Food item deleted successfully", response.Message)
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "異常系：不正なID",
			id:   "invalid",
			buildStubs: func() {
				// 不正なIDの場合はusecaseは呼ばれない
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusBadRequest, recorder.Code)
				var response Response
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "Invalid ID format", response.Message)
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodDelete, "/api/food-items/:id", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.SetParamNames("id")
			c.SetParamValues(tt.id)

			tt.buildStubs()

			err := foodItemController.DeleteFoodItem(c)
			assert.NoError(t, err)

			tt.checkResponse(t, rec)
		})
	}
}

================
File: controller/food_item_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"strconv"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

/**
 * 食材コントローラーのインターフェース
 */
type IFoodItemController interface {
	GetAllFoodItems(c echo.Context) error
	GetFoodItemById(c echo.Context) error
	CreateFoodItem(c echo.Context) error
	UpdateFoodItem(c echo.Context) error
	DeleteFoodItem(c echo.Context) error
}

/**
 * 食材コントローラーの構造体
 */
type foodItemController struct {
	fu usecase.IFoodItemUsecase
}

/**
 * APIレスポンスの構造体
 */
type Response struct {
	Data    interface{} `json:"data"`
	Message string      `json:"message,omitempty"`
}

/**
 * 食材コントローラーのコンストラクタ
 * @param fu 食材ユースケースのインターフェース
 * @return 食材コントローラーのインターフェース
 */
func NewFoodItemController(fu usecase.IFoodItemUsecase) IFoodItemController {
	return &foodItemController{fu}
}

/**
 * 全ての食材を取得
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) GetAllFoodItems(c echo.Context) error {
	foodItems, err := fc.fu.GetAllFoodItems()
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data: foodItems,
	})
}

/**
 * IDによる食材の取得
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) GetFoodItemById(c echo.Context) error {
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}

	foodItem, err := fc.fu.GetFoodItemById(uint(foodItemId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data: foodItem,
	})
}

/**
 * 食材の作成
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) CreateFoodItem(c echo.Context) error {
	foodItem := model.FoodItem{}
	if err := c.Bind(&foodItem); err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid request format",
		})
	}

	// JWTトークンからユーザーIDを取得
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(*jwt.MapClaims)
	userId := uint((*claims)["user_id"].(float64))
	foodItem.UserId = userId

	createdFoodItem, err := fc.fu.CreateFoodItem(foodItem)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusCreated, Response{
		Data:    createdFoodItem,
		Message: "Food item created successfully",
	})
}

/**
 * 食材の更新
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) UpdateFoodItem(c echo.Context) error {
	foodItem := model.FoodItem{}
	if err := c.Bind(&foodItem); err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid request format",
		})
	}

	// IDの存在確認
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}
	foodItem.ID = uint(foodItemId)

	if err := fc.fu.UpdateFoodItem(foodItem); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data:    foodItem,
		Message: "Food item updated successfully",
	})
}

/**
 * 食材の削除
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) DeleteFoodItem(c echo.Context) error {
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}

	if err := fc.fu.DeleteFoodItem(uint(foodItemId)); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Message: "Food item deleted successfully",
	})
}

================
File: controller/recipe_controller_test.go
================
package controller

import (
	"encoding/json"
	"errors"
	"go-rest-api/mock"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/golang-jwt/jwt/v5"
	"github.com/golang/mock/gomock"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
)

func TestRecipeController_GetRecipeSuggestions(t *testing.T) {
	// コントローラのセットアップ
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRecipeUsecase := mock.NewMockIRecipeUsecase(ctrl)
	recipeController := NewRecipeController(mockRecipeUsecase)

	// JWTトークンの生成
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": float64(1),
	})

	tests := []struct {
		name           string
		setupAuth      func(c echo.Context)
		buildStubs     func()
		checkResponse  func(t *testing.T, recorder *httptest.ResponseRecorder)
		expectedStatus int
	}{
		{
			name: "正常系：レシピ提案の取得成功",
			setupAuth: func(c echo.Context) {
				c.Set("user", token)
			},
			buildStubs: func() {
				mockRecipeUsecase.EXPECT().
					GetRecipeSuggestions(uint(1)).
					Times(1).
					Return("おすすめレシピ：トマトパスタ\n材料：トマト、パスタ、オリーブオイル\n手順：...", nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response []string
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Len(t, response, 1)
				assert.Contains(t, response[0], "おすすめレシピ")
			},
			expectedStatus: http.StatusOK,
		},
		{
			name: "異常系：認証トークンなし",
			setupAuth: func(c echo.Context) {
				// トークンを設定しない
			},
			buildStubs: func() {
				// 認証エラーの場合はusecaseは呼ばれない
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusInternalServerError, recorder.Code)
			},
			expectedStatus: http.StatusInternalServerError,
		},
		{
			name: "異常系：レシピ生成エラー",
			setupAuth: func(c echo.Context) {
				c.Set("user", token)
			},
			buildStubs: func() {
				mockRecipeUsecase.EXPECT().
					GetRecipeSuggestions(uint(1)).
					Times(1).
					Return("", errors.New("レシピ生成エラー"))
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusInternalServerError, recorder.Code)
				var response map[string]string
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Equal(t, "レシピの提案に失敗しました", response["error"])
			},
			expectedStatus: http.StatusInternalServerError,
		},
		{
			name: "正常系：食材なしの場合のメッセージ",
			setupAuth: func(c echo.Context) {
				c.Set("user", token)
			},
			buildStubs: func() {
				mockRecipeUsecase.EXPECT().
					GetRecipeSuggestions(uint(1)).
					Times(1).
					Return("食材が登録されていません。食材を追加してからレシピを取得してください。", nil)
			},
			checkResponse: func(t *testing.T, recorder *httptest.ResponseRecorder) {
				assert.Equal(t, http.StatusOK, recorder.Code)
				var response []string
				err := json.Unmarshal(recorder.Body.Bytes(), &response)
				assert.NoError(t, err)
				assert.Len(t, response, 1)
				assert.Contains(t, response[0], "食材が登録されていません")
			},
			expectedStatus: http.StatusOK,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Echoのセットアップ
			e := echo.New()
			req := httptest.NewRequest(http.MethodGet, "/api/recipes/suggestions", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			// 認証設定
			tt.setupAuth(c)

			// スタブの構築
			tt.buildStubs()

			// テスト実行
			err := recipeController.GetRecipeSuggestions(c)
			if err != nil {
				// エラーハンドリングの検証
				he, ok := err.(*echo.HTTPError)
				if ok {
					assert.Equal(t, tt.expectedStatus, he.Code)
				}
			}

			// レスポンスの検証
			tt.checkResponse(t, rec)
		})
	}
}

================
File: controller/recipe_controller.go
================
package controller

import (
	"go-rest-api/usecase"
	"net/http"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

type IRecipeController interface {
	GetRecipeSuggestions(c echo.Context) error
}

type recipeController struct {
	ru usecase.IRecipeUsecase
}

func NewRecipeController(ru usecase.IRecipeUsecase) IRecipeController {
	return &recipeController{ru}
}

func (rc *recipeController) GetRecipeSuggestions(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(*jwt.MapClaims)
	userId := uint((*claims)["user_id"].(float64))

	// レシピ提案を取得
	suggestions, err := rc.ru.GetRecipeSuggestions(userId)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "レシピの提案に失敗しました",
		})
	}

	return c.JSON(http.StatusOK, []string{suggestions})
}

================
File: controller/task_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"strconv"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

type ITaskController interface {
	GetAllTasks(c echo.Context) error
	GetTaskById(c echo.Context) error
	CreateTask(c echo.Context) error
	UpdateTask(c echo.Context) error
	DeleteTask(c echo.Context) error
}

type taskController struct {
	tu usecase.ITaskUsecase
}

func NewTaskController(tu usecase.ITaskUsecase) ITaskController {
	return &taskController{tu}
}

func (tc *taskController) GetAllTasks(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]

	tasksRes, err := tc.tu.GetAllTasks(uint(userId.(float64)))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, tasksRes)
}

func (tc *taskController) GetTaskById(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)
	taskRes, err := tc.tu.GetTaskById(uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, taskRes)
}

func (tc *taskController) CreateTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]

	task := model.Task{}
	if err := c.Bind(&task); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	task.UserId = uint(userId.(float64))
	taskRes, err := tc.tu.CreateTask(task)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusCreated, taskRes)
}

func (tc *taskController) UpdateTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)

	task := model.Task{}
	if err := c.Bind(&task); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	taskRes, err := tc.tu.UpdateTask(task, uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, taskRes)
}

func (tc *taskController) DeleteTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)

	err := tc.tu.DeleteTask(uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.NoContent(http.StatusNoContent)
}

================
File: controller/user_controller_test.go
================
package controller

import (
	"bytes"
	"encoding/json"
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
)

// mockUserUsecase はユーザーユースケースのモック
type mockUserUsecase struct {
	mockSignUp      func(user model.User) (model.UserResponse, error)
	mockLogin       func(user model.User) (string, error)
	mockVerifyToken func(tokenString string) error
}

func (m *mockUserUsecase) SignUp(user model.User) (model.UserResponse, error) {
	return m.mockSignUp(user)
}

func (m *mockUserUsecase) Login(user model.User) (string, error) {
	return m.mockLogin(user)
}

func (m *mockUserUsecase) VerifyToken(tokenString string) error {
	return m.mockVerifyToken(tokenString)
}

func TestUserController_SignUp(t *testing.T) {
	// テスト用のエコーインスタンスを作成
	e := echo.New()

	tests := []struct {
		name          string
		inputUser     model.User
		mockBehavior  func(*mockUserUsecase)
		expectedCode  int
		expectedError string
	}{
		{
			name: "正常系：ユーザー登録成功",
			inputUser: model.User{
				Email:    "test@example.com",
				Password: "password123",
			},
			mockBehavior: func(m *mockUserUsecase) {
				m.mockSignUp = func(user model.User) (model.UserResponse, error) {
					return model.UserResponse{
						ID:    1,
						Email: user.Email,
					}, nil
				}
			},
			expectedCode: http.StatusCreated,
		},
		{
			name: "異常系：既存のメールアドレス",
			inputUser: model.User{
				Email:    "existing@example.com",
				Password: "password123",
			},
			mockBehavior: func(m *mockUserUsecase) {
				m.mockSignUp = func(user model.User) (model.UserResponse, error) {
					return model.UserResponse{}, usecase.ErrEmailExists
				}
			},
			expectedCode:  http.StatusBadRequest,
			expectedError: usecase.ErrEmailExists.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// モックの準備
			mock := &mockUserUsecase{}
			tt.mockBehavior(mock)

			// コントローラーの作成
			uc := NewUserController(mock)

			// リクエストの準備
			jsonBody, _ := json.Marshal(tt.inputUser)
			req := httptest.NewRequest(http.MethodPost, "/signup", bytes.NewBuffer(jsonBody))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			// テスト実行
			err := uc.SignUp(c)
			assert.NoError(t, err)

			// レスポンスの検証
			assert.Equal(t, tt.expectedCode, rec.Code)

			if tt.expectedError != "" {
				var response map[string]string
				json.Unmarshal(rec.Body.Bytes(), &response)
				assert.Equal(t, tt.expectedError, response["message"])
			}
		})
	}
}

func TestUserController_Login(t *testing.T) {
	e := echo.New()

	tests := []struct {
		name          string
		inputUser     model.User
		mockBehavior  func(*mockUserUsecase)
		expectedCode  int
		expectedError string
	}{
		{
			name: "正常系：ログイン成功",
			inputUser: model.User{
				Email:    "test@example.com",
				Password: "password123",
			},
			mockBehavior: func(m *mockUserUsecase) {
				m.mockLogin = func(user model.User) (string, error) {
					return "test-jwt-token", nil
				}
			},
			expectedCode: http.StatusOK,
		},
		{
			name: "異常系：認証失敗",
			inputUser: model.User{
				Email:    "test@example.com",
				Password: "wrongpassword",
			},
			mockBehavior: func(m *mockUserUsecase) {
				m.mockLogin = func(user model.User) (string, error) {
					return "", usecase.ErrInvalidCredentials
				}
			},
			expectedCode:  http.StatusUnauthorized,
			expectedError: usecase.ErrInvalidCredentials.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// モックの準備
			mock := &mockUserUsecase{}
			tt.mockBehavior(mock)

			// コントローラーの作成
			uc := NewUserController(mock)

			// リクエストの準備
			jsonBody, _ := json.Marshal(tt.inputUser)
			req := httptest.NewRequest(http.MethodPost, "/login", bytes.NewBuffer(jsonBody))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			// テスト実行
			err := uc.LogIn(c)
			assert.NoError(t, err)

			// レスポンスの検証
			assert.Equal(t, tt.expectedCode, rec.Code)

			if tt.expectedError != "" {
				var response map[string]string
				json.Unmarshal(rec.Body.Bytes(), &response)
				assert.Equal(t, tt.expectedError, response["message"])
			}
		})
	}
}

func TestUserController_Logout(t *testing.T) {
	e := echo.New()

	t.Run("正常系：ログアウト成功", func(t *testing.T) {
		// コントローラーの作成
		mock := &mockUserUsecase{}
		uc := NewUserController(mock)

		// リクエストの準備
		req := httptest.NewRequest(http.MethodPost, "/logout", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		// テスト実行
		err := uc.LogOut(c)
		assert.NoError(t, err)

		// レスポンスの検証
		assert.Equal(t, http.StatusOK, rec.Code)

		// クッキーの検証
		cookies := rec.Result().Cookies()
		found := false
		for _, cookie := range cookies {
			if cookie.Name == "token" {
				found = true
				assert.Equal(t, "", cookie.Value)
				assert.True(t, cookie.Expires.Before(cookie.Expires))
			}
		}
		assert.True(t, found, "token cookieが見つかりません")
	})
}

func TestUserController_CsrfToken(t *testing.T) {
	e := echo.New()

	t.Run("正常系：CSRFトークン取得", func(t *testing.T) {
		// コントローラーの作成
		mock := &mockUserUsecase{}
		uc := NewUserController(mock)

		// リクエストの準備
		req := httptest.NewRequest(http.MethodGet, "/csrf", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("csrf", "test-csrf-token")

		// テスト実行
		err := uc.CsrfToken(c)
		assert.NoError(t, err)

		// レスポンスの検証
		assert.Equal(t, http.StatusOK, rec.Code)

		var response map[string]string
		json.Unmarshal(rec.Body.Bytes(), &response)
		assert.Equal(t, "test-csrf-token", response["csrf_token"])
	})
}

func TestUserController_VerifyToken(t *testing.T) {
	e := echo.New()

	t.Run("正常系：トークン検証成功", func(t *testing.T) {
		// コントローラーの作成
		mock := &mockUserUsecase{}
		uc := NewUserController(mock)

		// リクエストの準備
		req := httptest.NewRequest(http.MethodGet, "/verify", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		// テスト実行
		err := uc.VerifyToken(c)
		assert.NoError(t, err)

		// レスポンスの検証
		assert.Equal(t, http.StatusOK, rec.Code)

		var response map[string]string
		json.Unmarshal(rec.Body.Bytes(), &response)
		assert.Equal(t, "Token is valid", response["message"])
	})
}

================
File: controller/user_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
)

type IUserController interface {
	SignUp(c echo.Context) error
	LogIn(c echo.Context) error
	LogOut(c echo.Context) error
	CsrfToken(c echo.Context) error
	VerifyToken(c echo.Context) error
}

type userController struct {
	uu usecase.IUserUsecase
}

func NewUserController(uu usecase.IUserUsecase) IUserController {
	return &userController{uu}
}

func (uc *userController) SignUp(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid request format",
		})
	}
	userRes, err := uc.uu.SignUp(user)
	if err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": err.Error(),
		})
	}
	return c.JSON(http.StatusCreated, userRes)
}

func (uc *userController) LogIn(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid request format",
		})
	}
	tokenString, err := uc.uu.Login(user)
	if err != nil {
		return c.JSON(http.StatusUnauthorized, echo.Map{
			"message": err.Error(),
		})
	}

	cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = tokenString
	cookie.Expires = time.Now().Add(24 * time.Hour)
	cookie.Path = "/"
	cookie.Domain = "localhost"
	cookie.Secure = true
	cookie.HttpOnly = true
	cookie.SameSite = http.SameSiteNoneMode
	c.SetCookie(cookie)

	return c.JSON(http.StatusOK, echo.Map{
		"message": "Successfully logged in",
	})
}

func (uc *userController) LogOut(c echo.Context) error {
	cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = ""
	cookie.Expires = time.Now()
	cookie.Path = "/"
	cookie.Domain = "localhost"
	cookie.Secure = true
	cookie.HttpOnly = true
	cookie.SameSite = http.SameSiteNoneMode
	c.SetCookie(cookie)

	return c.JSON(http.StatusOK, echo.Map{
		"message": "Successfully logged out",
	})
}

func (uc *userController) CsrfToken(c echo.Context) error {
	token := c.Get("csrf").(string)
	return c.JSON(http.StatusOK, echo.Map{
		"csrf_token": token,
	})
}

func (uc *userController) VerifyToken(c echo.Context) error {
	// JWTミドルウェアによって既に検証されているため、
	// このエンドポイントに到達できた時点で有効なトークン
	return c.JSON(http.StatusOK, echo.Map{
		"message": "Token is valid",
	})
}

================
File: db/db.go
================
package db

import (
	"fmt"
	"log"
	"os"

	"github.com/joho/godotenv"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func NewDB() *gorm.DB {
	// 常に.envファイルを読み込む
	err := godotenv.Load("../.env")
	if err != nil {
		log.Printf("Warning: .env file not found: %v", err)
	}

	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Tokyo",
		os.Getenv("POSTGRES_HOST"),
		os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PW"),
		os.Getenv("POSTGRES_DB"),
		os.Getenv("POSTGRES_PORT"))

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println("Connected")
	return db
}

func CloseDB(db *gorm.DB) {
	sqlDB, _ := db.DB()
	if err := sqlDB.Close(); err != nil {
		log.Fatalln(err)
	}
}

================
File: migrate/migrate.go
================
package main

import (
	"fmt"
	"go-rest-api/db"
	"go-rest-api/model"
)

func main() {
	dbConn := db.NewDB()
	defer fmt.Println("Successfully Migrated")
	defer db.CloseDB(dbConn)
	dbConn.AutoMigrate(&model.User{}, &model.Task{}, &model.FoodItem{})
}

================
File: model/food_item_changes.md
================
# FoodItem モデルの変更点

## 既存の Task モデルからの変更点

### 共通のフィールド（変更なし）

- `ID` (uint): プライマリーキー
- `Title` (string): 名前（Task モデルの Title フィールドを流用）
- `CreatedAt` (time.Time): 作成日時
- `UpdatedAt` (time.Time): 更新日時
- `User` (User): ユーザーとの関連
- `UserId` (uint): ユーザー ID（外部キー）

### 新規追加フィールド

1. `Quantity` (int)

   - 食材の数量を管理
   - `gorm:"not null"` で必須項目として設定

2. `ExpiryDate` (time.Time)
   - 食材の賞味期限を管理
   - `gorm:"not null"` で必須項目として設定

## レスポンス構造体の変更点

### FoodItemResponse

- Task モデルの TaskResponse 構造体をベースに作成
- 新規フィールド（Quantity, ExpiryDate）を追加
- ユーザー情報は除外（TaskResponse と同様）

## マイグレーション

- `migrate.go` に `model.FoodItem{}` を追加
- 既存のマイグレーション機能を活用

## 注意点

- 既存の CRUD 処理を最大限活用
- ユーザーとの関連付けは Task モデルと同様の方式を採用
- 賞味期限による食材管理が可能な設計

================
File: model/food_item.go
================
package model

import "time"

// FoodItem represents a food item with its details.
type FoodItem struct {
	ID         uint      `json:"id" gorm:"primaryKey"`
	Title      string    `json:"title" gorm:"not null"`       // Reusing the Title field from Task
	Quantity   int       `json:"quantity" gorm:"not null"`    // New field for quantity
	ExpiryDate time.Time `json:"expiry_date" gorm:"not null"` // New field for expiry date
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	User       User      `json:"user" gorm:"foreignKey:UserId; constraint:OnDelete:CASCADE"`
	UserId     uint      `json:"user_id" gorm:"not null"`
}

// FoodItemResponse is the response structure for food items
type FoodItemResponse struct {
	ID         uint      `json:"id"`
	Title      string    `json:"title"`
	Quantity   int       `json:"quantity"`
	ExpiryDate time.Time `json:"expiry_date"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

================
File: model/task.go
================
package model

import "time"

type Task struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Title     string    `json:"title" gorm:"not null"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	User      User      `json:"user" gorm:"foreignKey:UserId; constraint:OnDelete:CASCADE"`
	UserId    uint      `json:"user_id" gorm:"not null"`
}

type TaskResponse struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Title     string    `json:"title" gorm:"not null"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

================
File: model/user.go
================
package model

import "time"

type User struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Email     string    `json:"email" gorm:"unique"`
	Password  string    `json:"password"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type UserResponse struct {
	ID    uint   `json:"id" gorm:"primaryKey"`
	Email string `json:"email" gorm:"unique"`
}

================
File: repository/food_item_repository.go
================
package repository

import (
	"go-rest-api/model"

	"gorm.io/gorm"
)

type IFoodItemRepository interface {
	GetAllFoodItems(foodItems *[]model.FoodItem) error
	GetFoodItemById(foodItem *model.FoodItem, id uint) error
	CreateFoodItem(foodItem *model.FoodItem) error
	UpdateFoodItem(foodItem *model.FoodItem) error
	DeleteFoodItem(id uint) error
}

type foodItemRepository struct {
	db *gorm.DB
}

func NewFoodItemRepository(db *gorm.DB) IFoodItemRepository {
	return &foodItemRepository{db}
}

func (fr *foodItemRepository) GetAllFoodItems(foodItems *[]model.FoodItem) error {
	if err := fr.db.Find(foodItems).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) GetFoodItemById(foodItem *model.FoodItem, id uint) error {
	if err := fr.db.First(foodItem, id).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) CreateFoodItem(foodItem *model.FoodItem) error {
	if err := fr.db.Create(foodItem).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) UpdateFoodItem(foodItem *model.FoodItem) error {
	if err := fr.db.Save(foodItem).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) DeleteFoodItem(id uint) error {
	if err := fr.db.Delete(&model.FoodItem{}, id).Error; err != nil {
		return err
	}
	return nil
}

================
File: repository/task_repositoty.go
================
package repository

import (
	"fmt"
	"go-rest-api/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type ITaskRepository interface {
	GetAllTasks(tasks *[]model.Task, userId uint) error
	GetTaskById(task *model.Task, userId uint, taskId uint) error
	CreateTask(task *model.Task) error
	UpdateTask(task *model.Task, userId uint, taskId uint) error
	DeleteTask(userId uint, taskId uint) error
}

type taskRepository struct {
	db *gorm.DB
}

func NewTaskRepository(db *gorm.DB) ITaskRepository {
	return &taskRepository{db}
}

func (tr *taskRepository) GetAllTasks(tasks *[]model.Task, userId uint) error {
	if err := tr.db.Joins("User").Where("user_id=?", userId).Order("created_at").Find(tasks).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) GetTaskById(task *model.Task, userId uint, taskId uint) error {
	if err := tr.db.Joins("User").Where("user_id=?", userId).First(task, taskId).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) CreateTask(task *model.Task) error {
	if err := tr.db.Create(task).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) UpdateTask(task *model.Task, userId uint, taskId uint) error {
	result := tr.db.Model(task).Clauses(clause.Returning{}).Where("id=? AND user_id=?", taskId, userId).Update("title", task.Title)
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected < 1 {
		return fmt.Errorf("object does not exist")
	}
	return nil
}

func (tr *taskRepository) DeleteTask(userId uint, taskId uint) error {
	result := tr.db.Where("id=? AND user_id=?", taskId, userId).Delete(&model.Task{})
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected < 1 {
		return fmt.Errorf("object does not exist")
	}
	return nil
}

================
File: repository/user_repository.go
================
package repository

import (
	"go-rest-api/model"

	"gorm.io/gorm"
)

type IUserRepository interface {
	GetUserByEmail(user *model.User, email string) error
	CreateUser(user *model.User) error
}

type userRepository struct {
	db *gorm.DB
}

func NewUserRepository(db *gorm.DB) IUserRepository {
	return &userRepository{db}
}

func (ur *userRepository) GetUserByEmail(user *model.User, email string) error {
	if err := ur.db.Where("email=?", email).First(user).Error; err != nil {
		return err
	}
	return nil
}

func (ur *userRepository) CreateUser(user *model.User) error {
	if err := ur.db.Create(user).Error; err != nil {
		return err
	}
	return nil
}

================
File: router/router.go
================
package router

import (
	"go-rest-api/controller"
	"net/http"
	"os"

	"github.com/golang-jwt/jwt/v5"
	echojwt "github.com/labstack/echo-jwt/v4"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func NewRouter(tc controller.ITaskController, uc controller.IUserController, fc controller.IFoodItemController, rc controller.IRecipeController) *echo.Echo {
	e := echo.New()

	// CORSミドルウェアの設定を修正
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     []string{"http://localhost:3000"},
		AllowMethods:     []string{"*"},
		AllowHeaders:     []string{"*"},
		AllowCredentials: true,
		MaxAge:           86400,
	}))

	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		CookiePath:     "/",
		CookieHTTPOnly: true,
		CookieSameSite: http.SameSiteDefaultMode,
		TokenLookup:    "header:X-CSRF-Token",
	}))

	// 認証関連
	e.POST("/signup", uc.SignUp)
	e.POST("/login", uc.LogIn)
	e.POST("/logout", uc.LogOut)
	e.GET("/csrf", uc.CsrfToken)

	// JWT認証が必要なルート
	api := e.Group("")
	api.Use(echojwt.WithConfig(echojwt.Config{
		NewClaimsFunc: func(c echo.Context) jwt.Claims {
			return new(jwt.MapClaims)
		},
		SigningKey:  []byte(os.Getenv("SECRET")),
		TokenLookup: "cookie:token",
	}))

	// トークン検証エンドポイント
	api.GET("/verify-token", uc.VerifyToken)

	// タスク関連
	tasks := api.Group("/tasks")
	tasks.GET("", tc.GetAllTasks)
	tasks.GET("/:taskId", tc.GetTaskById)
	tasks.POST("", tc.CreateTask)
	tasks.PUT("/:taskId", tc.UpdateTask)
	tasks.DELETE("/:taskId", tc.DeleteTask)

	// 食材関連
	foodItems := api.Group("/food-items")
	foodItems.GET("", fc.GetAllFoodItems)
	foodItems.GET("/:id", fc.GetFoodItemById)
	foodItems.POST("", fc.CreateFoodItem)
	foodItems.PUT("/:id", fc.UpdateFoodItem)
	foodItems.DELETE("/:id", fc.DeleteFoodItem)

	// レシピ関連
	recipes := api.Group("/recipes")
	recipes.GET("/suggestions", rc.GetRecipeSuggestions)

	return e
}

================
File: services/gemini_service_test.go
================
package services

import (
	"testing"
	"time"

	"go-rest-api/model"
	"go-rest-api/testutil"

	"github.com/stretchr/testify/assert"
)

func TestGeminiService_GenerateRecipe(t *testing.T) {
	// テストデータベースのセットアップ
	db := testutil.NewTestDB(t)
	defer db.Close()

	// テストユーザーの作成
	userID, _ := db.CreateTestUser(t)

	// テストケース
	tests := []struct {
		name        string
		ingredients []model.FoodItem
		wantErr     bool
		errMessage  string
	}{
		{
			name:        "空の食材リスト",
			ingredients: []model.FoodItem{},
			wantErr:     true,
			errMessage:  "食材が指定されていません",
		},
		{
			name: "有効な食材リスト",
			ingredients: []model.FoodItem{
				{
					ID:         1,
					UserId:     userID,
					Title:      "玉ねぎ",
					Quantity:   2,
					ExpiryDate: time.Now().AddDate(0, 0, 7),
				},
				{
					ID:         2,
					UserId:     userID,
					Title:      "じゃがいも",
					Quantity:   3,
					ExpiryDate: time.Now().AddDate(0, 0, 7),
				},
			},
			wantErr: false,
		},
		{
			name: "期限切れ食材を含む",
			ingredients: []model.FoodItem{
				{
					ID:         3,
					UserId:     userID,
					Title:      "期限切れ食材",
					Quantity:   1,
					ExpiryDate: time.Now().AddDate(0, 0, -1), // 昨日で期限切れ
				},
			},
			wantErr: false, // 期限切れ食材も受け付けるように変更
		},
	}

	// GeminiServiceのインスタンス作成
	service, err := NewGeminiService()
	if err != nil {
		t.Fatalf("GeminiServiceの作成に失敗: %v", err)
	}

	// テストケースの実行
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			recipe, err := service.GenerateRecipe(tt.ingredients)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMessage != "" {
					assert.Contains(t, err.Error(), tt.errMessage)
				}
			} else {
				assert.NoError(t, err)
				assert.NotEmpty(t, recipe)
				// レシピの内容に関する基本的な検証
				assert.Contains(t, recipe, "作り方")
				assert.Contains(t, recipe, "材料")
			}
		})
	}
}

func TestGeminiService_GenerateRecipe_LargeQuantity(t *testing.T) {
	// テストデータベースのセットアップ
	db := testutil.NewTestDB(t)
	defer db.Close()

	// テストユーザーの作成
	userID, _ := db.CreateTestUser(t)

	// 大量の食材データを生成
	var ingredients []model.FoodItem
	for i := 1; i <= 50; i++ {
		ingredients = append(ingredients, model.FoodItem{
			ID:         uint(i),
			UserId:     userID,
			Title:      "テスト食材",
			Quantity:   i,
			ExpiryDate: time.Now().AddDate(0, 0, 7),
		})
	}

	// GeminiServiceのインスタンス作成
	service, err := NewGeminiService()
	if err != nil {
		t.Fatalf("GeminiServiceの作成に失敗: %v", err)
	}

	// テスト実行
	recipe, err := service.GenerateRecipe(ingredients)
	assert.NoError(t, err)
	assert.NotEmpty(t, recipe)
	assert.Contains(t, recipe, "大量調理")
}

func TestGeminiService_GenerateRecipe_Performance(t *testing.T) {
	// テストデータベースのセットアップ
	db := testutil.NewTestDB(t)
	defer db.Close()

	// テストユーザーの作成
	userID, _ := db.CreateTestUser(t)

	// 標準的な食材リスト
	ingredients := []model.FoodItem{
		{
			ID:         1,
			UserId:     userID,
			Title:      "玉ねぎ",
			Quantity:   2,
			ExpiryDate: time.Now().AddDate(0, 0, 7),
		},
		{
			ID:         2,
			UserId:     userID,
			Title:      "じゃがいも",
			Quantity:   3,
			ExpiryDate: time.Now().AddDate(0, 0, 7),
		},
	}

	// GeminiServiceのインスタンス作成
	service, err := NewGeminiService()
	if err != nil {
		t.Fatalf("GeminiServiceの作成に失敗: %v", err)
	}

	// パフォーマンステスト
	start := time.Now()
	recipe, err := service.GenerateRecipe(ingredients)
	duration := time.Since(start)

	// アサーション
	assert.NoError(t, err)
	assert.NotEmpty(t, recipe)
	assert.Less(t, duration.Seconds(), 2.0, "レシピ生成は2秒以内に完了すべき")
}

================
File: services/gemini_service.go
================
package services

import (
	"context"
	"fmt"
	"go-rest-api/model"
	"os"
	"strings"
	"time"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

type IGeminiService interface {
	GenerateRecipe(foodItems []model.FoodItem) (string, error)
}

type geminiService struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

func NewGeminiService() (IGeminiService, error) {
	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
	if err != nil {
		return nil, fmt.Errorf("Gemini APIクライアントの作成に失敗しました: %v", err)
	}

	model := client.GenerativeModel("gemini-pro")
	return &geminiService{
		client: client,
		model:  model,
	}, nil
}

func (s *geminiService) GenerateRecipe(foodItems []model.FoodItem) (string, error) {
	if len(foodItems) == 0 {
		return "", fmt.Errorf("食材が指定されていません")
	}

	fmt.Printf("食材リスト: %+v\n", foodItems)

	// 期限切れ間近の食材を抽出
	var expiringItems []model.FoodItem
	for _, item := range foodItems {
		// 現在時刻と賞味期限の差を計算
		timeUntilExpiry := item.ExpiryDate.Sub(time.Now())
		daysUntilExpiry := timeUntilExpiry.Hours() / 24
		fmt.Printf("食材: %s, 期限まで: %.2f日\n", item.Title, daysUntilExpiry)

		// 7日以内に期限切れになる食材を追加
		if daysUntilExpiry >= 0 && daysUntilExpiry <= 7 {
			fmt.Printf("期限切れ間近の食材として追加: %s\n", item.Title)
			expiringItems = append(expiringItems, item)
		}
	}

	// すべての食材を使用
	if len(expiringItems) == 0 {
		fmt.Println("期限切れ間近の食材がないため、すべての食材を使用します")
		expiringItems = foodItems
	} else {
		fmt.Printf("期限切れ間近の食材数: %d\n", len(expiringItems))
	}

	// プロンプトの構築
	var promptBuilder strings.Builder
	promptBuilder.WriteString("以下の食材を使用した、栄養バランスの良いレシピを提案してください：\n\n")
	promptBuilder.WriteString("【食材リスト】\n")
	for _, item := range expiringItems {
		promptBuilder.WriteString(fmt.Sprintf("- %s（%d個）: 賞味期限 %s\n",
			item.Title,
			item.Quantity,
			item.ExpiryDate.Format("2006/01/02")))
	}
	promptBuilder.WriteString("\n【条件】\n")
	promptBuilder.WriteString("1. 上記の食材を優先的に使用すること\n")
	promptBuilder.WriteString("2. 栄養バランスを考慮すること\n")
	promptBuilder.WriteString("3. 調理手順は簡潔に記載すること\n")
	promptBuilder.WriteString("4. 必要な追加食材があれば提案すること\n")
	promptBuilder.WriteString("\n【出力形式】\n")
	promptBuilder.WriteString("1. レシピ名\n")
	promptBuilder.WriteString("2. 材料（2人分）\n")
	promptBuilder.WriteString("3. 調理手順\n")
	promptBuilder.WriteString("4. 栄養バランスの説明\n")

	// Gemini APIにリクエスト
	ctx := context.Background()
	resp, err := s.model.GenerateContent(ctx, genai.Text(promptBuilder.String()))
	if err != nil {
		return "", fmt.Errorf("レシピの生成に失敗しました: %v", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("レシピを生成できませんでした")
	}

	// レスポンスの取得とデバッグ出力
	fmt.Printf("Gemini API レスポンス: %+v\n", resp)

	if len(resp.Candidates) == 0 {
		return "", fmt.Errorf("レスポンスが空です")
	}

	if len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("レスポンスの内容が空です")
	}

	recipe, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		fmt.Printf("予期しないレスポンス形式: %T\n", resp.Candidates[0].Content.Parts[0])
		return "", fmt.Errorf("レスポンスの形式が不正です")
	}

	recipeStr := string(recipe)
	fmt.Printf("生成されたレシピ: %s\n", recipeStr)

	return recipeStr, nil
}

================
File: testutil/testutil.go
================
package testutil

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	_ "github.com/lib/pq"
)

// TestDB はテスト用のデータベース接続を保持する構造体
type TestDB struct {
	DB *sql.DB
}

// NewTestDB はテスト用のデータベース接続を作成する
func NewTestDB(t *testing.T) *TestDB {
	dbHost := os.Getenv("DB_HOST")
	dbUser := os.Getenv("DB_USER")
	dbPass := os.Getenv("DB_PASSWORD")
	dbName := os.Getenv("DB_NAME")
	dbPort := os.Getenv("DB_PORT")

	connStr := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		dbHost, dbPort, dbUser, dbPass, dbName,
	)

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		t.Fatalf("データベース接続エラー: %v", err)
	}

	// コネクション確認
	if err := db.Ping(); err != nil {
		t.Fatalf("データベースPingエラー: %v", err)
	}

	return &TestDB{DB: db}
}

// CleanupDB はテストデータベースをクリーンアップする
func (tdb *TestDB) CleanupDB(t *testing.T) {
	tables := []string{"food_items", "recipes", "users"}
	for _, table := range tables {
		_, err := tdb.DB.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
		if err != nil {
			t.Errorf("テーブル %s のクリーンアップに失敗: %v", table, err)
		}
	}
}

// Close はデータベース接続を閉じる
func (tdb *TestDB) Close() {
	if err := tdb.DB.Close(); err != nil {
		log.Printf("データベース接続のクローズに失敗: %v", err)
	}
}

// GenerateTestJWT はテスト用のJWTトークンを生成する
func GenerateTestJWT(userID uint) (string, error) {
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(time.Hour * 24).Unix(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	secretKey := []byte(os.Getenv("JWT_SECRET"))

	return token.SignedString(secretKey)
}

// ParseJWTToken はJWTトークンをパースしてクレームを返す
func ParseJWTToken(tokenString string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(os.Getenv("SECRET")), nil
	})

	if err != nil {
		return nil, fmt.Errorf("トークンのパースに失敗: %v", err)
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("無効なトークン")
}

// CreateTestUser はテスト用のユーザーを作成する
func (tdb *TestDB) CreateTestUser(t *testing.T) (uint, string) {
	var userID uint
	err := tdb.DB.QueryRow(`
		INSERT INTO users (email, password_hash, created_at, updated_at)
		VALUES ($1, $2, NOW(), NOW())
		RETURNING id
	`, "test@example.com", "hashedpassword").Scan(&userID)

	if err != nil {
		t.Fatalf("テストユーザーの作成に失敗: %v", err)
	}

	token, err := GenerateTestJWT(userID)
	if err != nil {
		t.Fatalf("JWTトークンの生成に失敗: %v", err)
	}

	return userID, token
}

// CreateTestFoodItem はテスト用の食材データを作成する
func (tdb *TestDB) CreateTestFoodItem(t *testing.T, userID uint) uint {
	var itemID uint
	err := tdb.DB.QueryRow(`
		INSERT INTO food_items (name, quantity, expiry_date, user_id, created_at, updated_at)
		VALUES ($1, $2, $3, $4, NOW(), NOW())
		RETURNING id
	`, "テスト食材", 1, time.Now().AddDate(0, 0, 7), userID).Scan(&itemID)

	if err != nil {
		t.Fatalf("テスト食材の作成に失敗: %v", err)
	}

	return itemID
}

// AssertHTTPStatus はHTTPステータスコードを検証する
func AssertHTTPStatus(t *testing.T, got, want int) {
	t.Helper()
	if got != want {
		t.Errorf("HTTPステータスコードが一致しません: got %d, want %d", got, want)
	}
}

// AssertErrorMessage はエラーメッセージを検証する
func AssertErrorMessage(t *testing.T, got, want string) {
	t.Helper()
	if got != want {
		t.Errorf("エラーメッセージが一致しません: got %q, want %q", got, want)
	}
}

================
File: usecase/errors.go
================
package usecase

import "errors"

var (
	ErrInvalidEmail       = errors.New("メールアドレスが無効です")
	ErrInvalidCredentials = errors.New("メールアドレスまたはパスワードが正しくありません")
	ErrEmailExists        = errors.New("このメールアドレスは既に登録されています")
	ErrHashPassword       = errors.New("パスワードのハッシュ化に失敗しました")
	ErrCreateUser         = errors.New("ユーザーの作成に失敗しました")
	ErrGenerateToken      = errors.New("トークンの生成に失敗しました")
)

================
File: usecase/food_item_usecase.go
================
package usecase

import (
	"go-rest-api/model"
	"go-rest-api/repository"
)

type IFoodItemUsecase interface {
	GetAllFoodItems() ([]model.FoodItem, error)
	GetFoodItemById(id uint) (model.FoodItem, error)
	CreateFoodItem(foodItem model.FoodItem) (model.FoodItem, error)
	UpdateFoodItem(foodItem model.FoodItem) error
	DeleteFoodItem(id uint) error
}

type foodItemUsecase struct {
	fr repository.IFoodItemRepository
}

func NewFoodItemUsecase(fr repository.IFoodItemRepository) IFoodItemUsecase {
	return &foodItemUsecase{fr}
}

func (fu *foodItemUsecase) GetAllFoodItems() ([]model.FoodItem, error) {
	foodItems := []model.FoodItem{}
	if err := fu.fr.GetAllFoodItems(&foodItems); err != nil {
		return nil, err
	}
	return foodItems, nil
}

func (fu *foodItemUsecase) GetFoodItemById(id uint) (model.FoodItem, error) {
	foodItem := model.FoodItem{}
	if err := fu.fr.GetFoodItemById(&foodItem, id); err != nil {
		return model.FoodItem{}, err
	}
	return foodItem, nil
}

func (fu *foodItemUsecase) CreateFoodItem(foodItem model.FoodItem) (model.FoodItem, error) {
	if err := fu.fr.CreateFoodItem(&foodItem); err != nil {
		return model.FoodItem{}, err
	}
	return foodItem, nil
}

func (fu *foodItemUsecase) UpdateFoodItem(foodItem model.FoodItem) error {
	if err := fu.fr.UpdateFoodItem(&foodItem); err != nil {
		return err
	}
	return nil
}

func (fu *foodItemUsecase) DeleteFoodItem(id uint) error {
	if err := fu.fr.DeleteFoodItem(id); err != nil {
		return err
	}
	return nil
}

================
File: usecase/recipe_usecase_test.go
================
package usecase

import (
	"go-rest-api/model"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFoodItemRepository struct {
	mock.Mock
}

func (m *MockFoodItemRepository) GetAllFoodItems(foodItems *[]model.FoodItem) error {
	args := m.Called(foodItems)
	if items, ok := args.Get(0).([]model.FoodItem); ok {
		*foodItems = items
	}
	return args.Error(1)
}

func (m *MockFoodItemRepository) GetFoodItemById(foodItem *model.FoodItem, id uint) error {
	args := m.Called(foodItem, id)
	return args.Error(0)
}

func (m *MockFoodItemRepository) CreateFoodItem(foodItem *model.FoodItem) error {
	args := m.Called(foodItem)
	return args.Error(0)
}

func (m *MockFoodItemRepository) UpdateFoodItem(foodItem *model.FoodItem) error {
	args := m.Called(foodItem)
	return args.Error(0)
}

func (m *MockFoodItemRepository) DeleteFoodItem(id uint) error {
	args := m.Called(id)
	return args.Error(0)
}

type MockGeminiService struct {
	mock.Mock
}

func (m *MockGeminiService) GenerateRecipe(foodItems []model.FoodItem) (string, error) {
	args := m.Called(foodItems)
	return args.String(0), args.Error(1)
}

func TestGetRecipeSuggestions(t *testing.T) {
	t.Run("期限切れ間近の食材がある場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// テストデータ
		foodItems := []model.FoodItem{
			{
				ID:         1,
				Title:      "トマト",
				Quantity:   2,
				ExpiryDate: time.Now().Add(24 * time.Hour * 3), // 3日後
			},
		}
		expectedRecipe := "トマトを使用したレシピ..."

		// モックの設定
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Run(func(args mock.Arguments) {
				arg := args.Get(0).(*[]model.FoodItem)
				*arg = foodItems
			}).
			Return(foodItems, nil)

		mockGemini.On("GenerateRecipe", foodItems).
			Return(expectedRecipe, nil)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.NoError(t, err)
		assert.Equal(t, expectedRecipe, recipe)
		mockRepo.AssertExpectations(t)
		mockGemini.AssertExpectations(t)
	})

	t.Run("食材が存在しない場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// モックの設定
		var emptyFoodItems []model.FoodItem
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Run(func(args mock.Arguments) {
				arg := args.Get(0).(*[]model.FoodItem)
				*arg = emptyFoodItems
			}).
			Return(emptyFoodItems, nil)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.Error(t, err)
		assert.Empty(t, recipe)
		assert.Contains(t, err.Error(), "食材が登録されていません")
		mockRepo.AssertExpectations(t)
	})

	t.Run("リポジトリでエラーが発生した場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// モックの設定
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Return([]model.FoodItem{}, assert.AnError)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.Error(t, err)
		assert.Empty(t, recipe)
		mockRepo.AssertExpectations(t)
	})
}

================
File: usecase/recipe_usecase.go
================
package usecase

import (
	"fmt"
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/services"
)

type IRecipeUsecase interface {
	GetRecipeSuggestions(userId uint) (string, error)
}

type recipeUsecase struct {
	fr repository.IFoodItemRepository
	gs services.IGeminiService
}

func NewRecipeUsecase(fr repository.IFoodItemRepository, gs services.IGeminiService) IRecipeUsecase {
	return &recipeUsecase{fr, gs}
}

func (ru *recipeUsecase) GetRecipeSuggestions(userId uint) (string, error) {
	// ユーザーの食材一覧を取得
	var foodItems []model.FoodItem
	if err := ru.fr.GetAllFoodItems(&foodItems); err != nil {
		return "", fmt.Errorf("食材の取得に失敗しました: %v", err)
	}

	// 食材が存在しない場合は適切なメッセージを返す
	if len(foodItems) == 0 {
		return "食材が登録されていません。食材を追加してからレシピを取得してください。", nil
	}

	// レシピを生成
	recipe, err := ru.gs.GenerateRecipe(foodItems)
	if err != nil {
		// Geminiサービスのエラーをログに出力
		fmt.Printf("Geminiサービスエラー: %v\n", err)
		return "レシピの生成中にエラーが発生しました。しばらく待ってから再試行してください。", nil
	}

	if recipe == "" {
		return "レシピを生成できませんでした。別の食材を試してみてください。", nil
	}

	return recipe, nil
}

================
File: usecase/task_usecase.go
================
package usecase

import (
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/validator"
)

type ITaskUsecase interface {
	GetAllTasks(userId uint) ([]model.TaskResponse, error)
	GetTaskById(userId uint, taskId uint) (model.TaskResponse, error)
	CreateTask(task model.Task) (model.TaskResponse, error)
	UpdateTask(task model.Task, userId uint, taskId uint) (model.TaskResponse, error)
	DeleteTask(userId uint, taskId uint) error
}

type taskUsecase struct {
	tr repository.ITaskRepository
	tv validator.ITaskValidator
}

func NewTaskUsecase(tr repository.ITaskRepository, tv validator.ITaskValidator) ITaskUsecase {
	return &taskUsecase{tr, tv}
}

func (tu *taskUsecase) GetAllTasks(userId uint) ([]model.TaskResponse, error) {
	tasks := []model.Task{}
	if err := tu.tr.GetAllTasks(&tasks, userId); err != nil {
		return nil, err
	}
	resTasks := []model.TaskResponse{}
	for _, v := range tasks {
		t := model.TaskResponse{
			ID:        v.ID,
			Title:     v.Title,
			CreatedAt: v.CreatedAt,
			UpdatedAt: v.UpdatedAt,
		}
		resTasks = append(resTasks, t)
	}
	return resTasks, nil
}

func (tu *taskUsecase) GetTaskById(userId uint, taskId uint) (model.TaskResponse, error) {
	task := model.Task{}
	if err := tu.tr.GetTaskById(&task, userId, taskId); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) CreateTask(task model.Task) (model.TaskResponse, error) {
	if err := tu.tv.TaskValidate(task); err != nil {
		return model.TaskResponse{}, err
	}
	if err := tu.tr.CreateTask(&task); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) UpdateTask(task model.Task, userId uint, taskId uint) (model.TaskResponse, error) {
	if err := tu.tv.TaskValidate(task); err != nil {
		return model.TaskResponse{}, err
	}
	if err := tu.tr.UpdateTask(&task, userId, taskId); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) DeleteTask(userId uint, taskId uint) error {
	if err := tu.tr.DeleteTask(userId, taskId); err != nil {
		return err
	}
	return nil
}

================
File: usecase/user_usecase_test.go
================
package usecase

import (
	"go-rest-api/model"
	"go-rest-api/testutil"
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/crypto/bcrypt"
)

// モックリポジトリの定義
type MockUserRepository struct {
	mock.Mock
}

func (m *MockUserRepository) CreateUser(user *model.User) error {
	args := m.Called(user)
	return args.Error(0)
}

func (m *MockUserRepository) GetUserByEmail(user *model.User, email string) error {
	args := m.Called(user, email)
	if args.Error(0) != nil {
		return args.Error(0)
	}
	// モックユーザーデータの設定
	if mockUser, ok := args.Get(1).(*model.User); ok && mockUser != nil {
		*user = *mockUser
	}
	return nil
}

// モックバリデータの定義
type MockUserValidator struct {
	mock.Mock
}

func (m *MockUserValidator) UserValidate(user model.User) error {
	args := m.Called(user)
	return args.Error(0)
}

func TestUserUsecase_SignUp(t *testing.T) {
	// テスト用の環境変数設定
	os.Setenv("SECRET", "test_secret_key")
	defer os.Unsetenv("SECRET")

	tests := []struct {
		name       string
		user       model.User
		setupMocks func(*MockUserRepository, *MockUserValidator)
		wantErr    bool
		errMessage string
	}{
		{
			name: "正常な新規登録",
			user: model.User{
				Email:    "test@example.com",
				Password: "validPassword123",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(nil)
				ur.On("GetUserByEmail", mock.Anything, "test@example.com").Return(assert.AnError) // ユーザーが存在しない
				ur.On("CreateUser", mock.Anything).Return(nil)
			},
			wantErr: false,
		},
		{
			name: "重複メールアドレス",
			user: model.User{
				Email:    "existing@example.com",
				Password: "validPassword123",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(nil)
				ur.On("GetUserByEmail", mock.Anything, "existing@example.com").Return(nil)
			},
			wantErr:    true,
			errMessage: "email already exists",
		},
		{
			name: "バリデーションエラー",
			user: model.User{
				Email:    "invalid-email",
				Password: "short",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(assert.AnError)
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// モックの準備
			ur := new(MockUserRepository)
			uv := new(MockUserValidator)
			tt.setupMocks(ur, uv)

			// ユースケースの作成
			uu := NewUserUsecase(ur, uv)

			// テスト実行
			_, err := uu.SignUp(tt.user)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMessage != "" {
					assert.Contains(t, err.Error(), tt.errMessage)
				}
			} else {
				assert.NoError(t, err)
			}

			// モックの検証
			ur.AssertExpectations(t)
			uv.AssertExpectations(t)
		})
	}
}

func TestUserUsecase_Login(t *testing.T) {
	// テスト用の環境変数設定
	os.Setenv("SECRET", "test_secret_key")
	defer os.Unsetenv("SECRET")

	// テスト用のハッシュ化されたパスワード
	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("correctPassword123"), 10)

	tests := []struct {
		name       string
		user       model.User
		setupMocks func(*MockUserRepository, *MockUserValidator)
		wantErr    bool
		errMessage string
	}{
		{
			name: "正常なログイン",
			user: model.User{
				Email:    "test@example.com",
				Password: "correctPassword123",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(nil)
				ur.On("GetUserByEmail", mock.Anything, "test@example.com").Return(nil, &model.User{
					ID:       1,
					Email:    "test@example.com",
					Password: string(hashedPassword),
				})
			},
			wantErr: false,
		},
		{
			name: "存在しないユーザー",
			user: model.User{
				Email:    "nonexistent@example.com",
				Password: "password123",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(nil)
				ur.On("GetUserByEmail", mock.Anything, "nonexistent@example.com").Return(assert.AnError)
			},
			wantErr:    true,
			errMessage: "invalid email or password",
		},
		{
			name: "パスワード不一致",
			user: model.User{
				Email:    "test@example.com",
				Password: "wrongPassword123",
			},
			setupMocks: func(ur *MockUserRepository, uv *MockUserValidator) {
				uv.On("UserValidate", mock.Anything).Return(nil)
				ur.On("GetUserByEmail", mock.Anything, "test@example.com").Return(nil, &model.User{
					ID:       1,
					Email:    "test@example.com",
					Password: string(hashedPassword),
				})
			},
			wantErr:    true,
			errMessage: "invalid email or password",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// モックの準備
			ur := new(MockUserRepository)
			uv := new(MockUserValidator)
			tt.setupMocks(ur, uv)

			// ユースケースの作成
			uu := NewUserUsecase(ur, uv)

			// テスト実行
			token, err := uu.Login(tt.user)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMessage != "" {
					assert.Contains(t, err.Error(), tt.errMessage)
				}
				assert.Empty(t, token)
			} else {
				assert.NoError(t, err)
				assert.NotEmpty(t, token)

				// JWTトークンの検証
				claims, err := testutil.ParseJWTToken(token)
				assert.NoError(t, err)
				assert.Equal(t, uint(1), uint(claims["user_id"].(float64)))
				assert.Equal(t, "test@example.com", claims["email"].(string))

				// 有効期限の検証
				exp := time.Unix(int64(claims["exp"].(float64)), 0)
				assert.True(t, exp.After(time.Now()))
				assert.True(t, exp.Before(time.Now().Add(13*time.Hour))) // 12時間 + バッファ
			}

			// モックの検証
			ur.AssertExpectations(t)
			uv.AssertExpectations(t)
		})
	}
}

================
File: usecase/user_usecase.go
================
package usecase

import (
	"errors"
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/validator"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

type IUserUsecase interface {
	SignUp(user model.User) (model.UserResponse, error)
	Login(user model.User) (string, error)
}

type userUsecase struct {
	ur repository.IUserRepository
	uv validator.IUserValidator
}

func NewUserUsecase(ur repository.IUserRepository, uv validator.IUserValidator) IUserUsecase {
	return &userUsecase{ur, uv}
}

func (uu *userUsecase) SignUp(user model.User) (model.UserResponse, error) {
	if err := uu.uv.UserValidate(user); err != nil {
		return model.UserResponse{}, err
	}

	// メールアドレスの重複チェック
	var existingUser model.User
	if err := uu.ur.GetUserByEmail(&existingUser, user.Email); err == nil {
		return model.UserResponse{}, errors.New("email already exists")
	}

	hash, err := bcrypt.GenerateFromPassword([]byte(user.Password), 10)
	if err != nil {
		return model.UserResponse{}, errors.New("failed to hash password")
	}

	newUser := model.User{Email: user.Email, Password: string(hash)}
	if err := uu.ur.CreateUser(&newUser); err != nil {
		return model.UserResponse{}, errors.New("failed to create user")
	}

	resUser := model.UserResponse{
		ID:    newUser.ID,
		Email: newUser.Email,
	}
	return resUser, nil
}

func (uu *userUsecase) Login(user model.User) (string, error) {
	if err := uu.uv.UserValidate(user); err != nil {
		return "", err
	}

	storedUser := model.User{}
	if err := uu.ur.GetUserByEmail(&storedUser, user.Email); err != nil {
		return "", errors.New("invalid email or password")
	}

	err := bcrypt.CompareHashAndPassword([]byte(storedUser.Password), []byte(user.Password))
	if err != nil {
		return "", errors.New("invalid email or password")
	}

	// JWTトークンの生成
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": storedUser.ID,
		"email":   storedUser.Email,
		"exp":     time.Now().Add(time.Hour * 12).Unix(),
	})

	tokenString, err := token.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		return "", errors.New("failed to generate token")
	}

	return tokenString, nil
}

================
File: validator/task_validator.go
================
package validator

import (
	"go-rest-api/model"

	validation "github.com/go-ozzo/ozzo-validation/v4"
)

type ITaskValidator interface {
	TaskValidate(task model.Task) error
}

type taskValidator struct{}

func NewTaskValidator() ITaskValidator {
	return &taskValidator{}
}

func (tv *taskValidator) TaskValidate(task model.Task) error {
	return validation.ValidateStruct(&task,
		validation.Field(
			&task.Title,
			validation.Required.Error("title is required"),
			validation.RuneLength(1, 10).Error("limited max 10 char"),
		),
	)
}

================
File: validator/user_validator.go
================
package validator

import (
	"go-rest-api/model"

	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/go-ozzo/ozzo-validation/v4/is"
)

type IUserValidator interface {
	UserValidate(user model.User) error
}

type userValidator struct{}

func NewUserValidator() IUserValidator {
	return &userValidator{}
}

func (uv *userValidator) UserValidate(user model.User) error {
	return validation.ValidateStruct(&user,
		validation.Field(
			&user.Email,
			validation.Required.Error("email is required"),
			validation.RuneLength(1, 30).Error("limited max 30 char"),
			is.Email.Error("is not valid email format"),
		),
		validation.Field(
			&user.Password,
			validation.Required.Error("password is required"),
			validation.RuneLength(6, 30).Error("limited min 6 max 30 char"),
		),
	)
}

================
File: .env.test
================
DB_HOST=db_test
DB_USER=test_user
DB_PASSWORD=test_password
DB_NAME=smart_pantry_test
DB_PORT=5432
JWT_SECRET=test_jwt_secret_key_for_testing_purposes_only
API_PORT=8080
GO_ENV=test
GEMINI_API_KEY=${GEMINI_API_KEY}

# テスト用設定
TEST_TIMEOUT=2s
TEST_DB_MAX_CONNECTIONS=10
TEST_DB_MAX_IDLE_CONNECTIONS=5
TEST_DB_MAX_LIFETIME=1h

# モックサービス設定
MOCK_EXTERNAL_API_PORT=8081
MOCK_EXTERNAL_API_RESPONSE_DELAY=100ms

================
File: docker-compose.test.yml
================
version: "3.8"

services:
  app_test:
    build:
      context: .
      dockerfile: Dockerfile
      target: test
    volumes:
      - .:/app
    environment:
      - DB_HOST=db_test
      - DB_USER=test_user
      - DB_PASSWORD=test_password
      - DB_NAME=smart_pantry_test
      - JWT_SECRET=test_secret
      - GEMINI_API_KEY=${GEMINI_API_KEY}
    depends_on:
      - db_test
    command: go test -v -cover ./...

  db_test:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=test_user
      - POSTGRES_PASSWORD=test_password
      - POSTGRES_DB=smart_pantry_test
    ports:
      - "5433:5432"
    tmpfs:
      - /var/lib/postgresql/data

================
File: docker-compose.yml
================
services:
  db:
    image: postgres:15-alpine
    container_name: smart_pantry_db
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PW:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-smart_pantry}
      TZ: "Asia/Tokyo"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local

================
File: Dockerfile
================
# ベースイメージとして最新のGolangイメージを使用
FROM golang:1.21-alpine AS base

# 必要なパッケージのインストール
RUN apk add --no-cache gcc musl-dev git

# 作業ディレクトリの設定
WORKDIR /app

# 依存関係のコピーとダウンロード
COPY go.mod go.sum ./
RUN go mod download

# ソースコードのコピー
COPY . .

# テストステージ
FROM base AS test
RUN go install github.com/golang/mock/mockgen@v1.6.0
ENV CGO_ENABLED=1
ENV GO_ENV=test
CMD ["go", "test", "-v", "./..."]

# ビルドステージ
FROM base AS builder
RUN go build -o main .

# 本番ステージ
FROM alpine:latest AS production
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
COPY --from=builder /app/.env .
EXPOSE 8080
CMD ["./main"]

================
File: go.mod
================
module go-rest-api

go 1.23.4

require (
	github.com/go-ozzo/ozzo-validation/v4 v4.3.0
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/generative-ai-go v0.19.0
	github.com/joho/godotenv v1.5.1
	github.com/labstack/echo-jwt/v4 v4.3.0
	github.com/labstack/echo/v4 v4.13.3
	github.com/stretchr/testify v1.10.0
	golang.org/x/crypto v0.32.0
	google.golang.org/api v0.218.0
	gorm.io/driver/postgres v1.5.11
	gorm.io/gorm v1.25.12
)

require (
	cloud.google.com/go v0.115.0 // indirect
	cloud.google.com/go/ai v0.8.0 // indirect
	cloud.google.com/go/auth v0.14.0 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.7 // indirect
	cloud.google.com/go/compute/metadata v0.6.0 // indirect
	cloud.google.com/go/longrunning v0.5.7 // indirect
	github.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/golang/mock v1.6.0 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/googleapis/gax-go/v2 v2.14.1 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.5.5 // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rogpeppe/go-internal v1.13.1 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect
	go.opentelemetry.io/otel v1.31.0 // indirect
	go.opentelemetry.io/otel/metric v1.31.0 // indirect
	go.opentelemetry.io/otel/trace v1.31.0 // indirect
	golang.org/x/net v0.34.0 // indirect
	golang.org/x/oauth2 v0.25.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250115164207-1a7da9e5054f // indirect
	google.golang.org/grpc v1.69.4 // indirect
	google.golang.org/protobuf v1.36.3 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: main.go
================
package main

import (
	"go-rest-api/controller"
	"go-rest-api/db"
	"go-rest-api/repository"
	"go-rest-api/router"
	"go-rest-api/services"
	"go-rest-api/usecase"
	"go-rest-api/validator"
	"log"
)

func main() {
	db := db.NewDB()
	userValidator := validator.NewUserValidator()
	taskValidator := validator.NewTaskValidator()

	// リポジトリの初期化
	userRepository := repository.NewUserRepository(db)
	taskRepository := repository.NewTaskRepository(db)
	foodItemRepository := repository.NewFoodItemRepository(db)

	// サービスの初期化
	geminiService, err := services.NewGeminiService()
	if err != nil {
		log.Fatalf("Failed to initialize Gemini service: %v", err)
	}

	// ユースケースの初期化
	userUsecase := usecase.NewUserUsecase(userRepository, userValidator)
	taskUsecase := usecase.NewTaskUsecase(taskRepository, taskValidator)
	foodItemUsecase := usecase.NewFoodItemUsecase(foodItemRepository)
	recipeUsecase := usecase.NewRecipeUsecase(foodItemRepository, geminiService)

	// コントローラーの初期化
	userController := controller.NewUserController(userUsecase)
	taskController := controller.NewTaskController(taskUsecase)
	foodItemController := controller.NewFoodItemController(foodItemUsecase)
	recipeController := controller.NewRecipeController(recipeUsecase)

	// ルーターの設定
	e := router.NewRouter(taskController, userController, foodItemController, recipeController)
	e.Logger.Fatal(e.Start(":8080"))
}
