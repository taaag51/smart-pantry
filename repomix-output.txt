This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-31T23:04:56.804Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  ARCHITECTURE.md
go-rest-api/
  controller/
    food_item_controller.go
    recipe_controller.go
    task_controller.go
    user_controller.go
  db/
    db.go
  migrate/
    migrate.go
  model/
    food_item_changes.md
    food_item.go
    task.go
    user.go
  repository/
    food_item_repository.go
    task_repositoty.go
    user_repository.go
  router/
    router.go
  services/
    gemini_service_test.go
    gemini_service.go
  usecase/
    food_item_usecase.go
    recipe_usecase_test.go
    recipe_usecase.go
    task_usecase.go
    user_usecase.go
  validator/
    task_validator.go
    user_validator.go
  docker-compose.yml
  go.mod
  main.go
react-todo/
  public/
    index.html
    manifest.json
    robots.txt
  src/
    components/
      __tests__/
        FoodItem.test.tsx
        FoodList.test.tsx
        RecipeSuggestions.test.tsx
      Auth.tsx
      FoodItem.tsx
      FoodItemForm.tsx
      FoodList.tsx
      Layout.tsx
      Navigation.tsx
      RecipeSuggestions.tsx
      TaskItem.tsx
      Todo.tsx
    hooks/
      useAuth.ts
      useError.ts
      useFoodItemForm.ts
      useMutateAuth.ts
      useMutateFoodItem.ts
      useMutateTask.ts
      useQueryFoodItems.ts
      useQueryRecipe.ts
      useQueryTasks.ts
    lib/
      axios.ts
    pages/
      PantryPage.tsx
    store/
      index.ts
    types/
      index.ts
    App.tsx
    index.css
    index.tsx
    logo.svg
    react-app-env.d.ts
    reportWebVitals.ts
    setupTests.ts
  .gitignore
  .prettierrc
  package.json
  README.md
  tailwind.config.js
  tsconfig.json
.env.example
.gitignore
README.md

================================================================
Files
================================================================

================
File: docs/ARCHITECTURE.md
================
# スマートパントリーアプリケーション アーキテクチャ設計

## 概要

このアプリケーションは、食材管理を効率化するための Web アプリケーションです。
フロントエンドは React、バックエンドは Go 言語で実装されています。

## アーキテクチャの特徴

### フロントエンド（React + TypeScript）

#### コンポーネント設計

1. **プレゼンテーショナルコンポーネント**

   - UI の表示に特化
   - ビジネスロジックを含まない
   - 例：`FoodItemForm.tsx`

2. **カスタムフック**
   - ビジネスロジックの分離
   - 再利用可能な状態管理
   - 例：`useFoodItemForm.ts`, `useMutateFoodItem.ts`

#### 状態管理

- React Query による効率的なサーバー状態管理
- ローカル状態は React の useState を使用
- キャッシュの最適化

### バックエンド（Go + Echo）

#### レイヤードアーキテクチャ

1. **コントローラー層**

   - HTTP リクエストのハンドリング
   - バリデーション
   - レスポンス形式の統一

   ```go
   type Response struct {
       Data    interface{} `json:"data"`
       Message string      `json:"message,omitempty"`
   }
   ```

2. **ユースケース層**

   - ビジネスロジックの実装
   - トランザクション管理

3. **リポジトリ層**
   - データベースアクセス
   - データの永続化

## データフロー

### 食材追加の例

1. ユーザーが食材フォームに入力
2. `FoodItemForm` コンポーネントが入力を受け取る
3. `useFoodItemForm` フックがバリデーションを実行
4. `useMutateFoodItem` フックが API リクエストを送信
5. バックエンドの `FoodItemController` がリクエストを受信
6. ユースケース層でビジネスロジックを実行
7. データベースに保存
8. レスポンスをフロントエンドに返却
9. React Query がキャッシュを更新
10. UI が自動的に更新

## エラーハンドリング

### フロントエンド

- カスタムフックによる一元化されたエラー処理
- ユーザーフレンドリーなエラーメッセージ
- フォームバリデーション

### バックエンド

- 統一されたエラーレスポンス形式
- 適切な HTTP ステータスコードの使用
- 詳細なエラーメッセージ

## セキュリティ

- JWT による認証
- CSRF トークンの使用
- 入力値のバリデーション
- SQL インジェクション対策

## パフォーマンス最適化

### フロントエンド

- React Query によるキャッシュ管理
- 必要最小限のレンダリング
- コンポーネントの適切な分割

### バックエンド

- データベースクエリの最適化
- キャッシュの活用
- 効率的なルーティング

## 開発ガイドライン

1. **コンポーネント作成**

   - 単一責任の原則に従う
   - プレゼンテーショナルとコンテナの分離
   - 適切なコメント付与

2. **カスタムフック作成**

   - ロジックの再利用性を重視
   - 明確な命名規則
   - 型定義の徹底

3. **API エンドポイント作成**

   - RESTful 原則に従う
   - 統一されたレスポンス形式
   - 適切なエラーハンドリング

4. **テスト**
   - ユニットテストの作成
   - インテグレーションテスト
   - E2E テスト

## 今後の改善点

1. キャッシュ戦略の最適化
2. パフォーマンスモニタリングの導入
3. エラーログの集中管理
4. CI/CD パイプラインの強化

================
File: go-rest-api/controller/food_item_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"strconv"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

/**
 * 食材コントローラーのインターフェース
 */
type IFoodItemController interface {
	GetAllFoodItems(c echo.Context) error
	GetFoodItemById(c echo.Context) error
	CreateFoodItem(c echo.Context) error
	UpdateFoodItem(c echo.Context) error
	DeleteFoodItem(c echo.Context) error
}

/**
 * 食材コントローラーの構造体
 */
type foodItemController struct {
	fu usecase.IFoodItemUsecase
}

/**
 * APIレスポンスの構造体
 */
type Response struct {
	Data    interface{} `json:"data"`
	Message string      `json:"message,omitempty"`
}

/**
 * 食材コントローラーのコンストラクタ
 * @param fu 食材ユースケースのインターフェース
 * @return 食材コントローラーのインターフェース
 */
func NewFoodItemController(fu usecase.IFoodItemUsecase) IFoodItemController {
	return &foodItemController{fu}
}

/**
 * 全ての食材を取得
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) GetAllFoodItems(c echo.Context) error {
	foodItems, err := fc.fu.GetAllFoodItems()
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data: foodItems,
	})
}

/**
 * IDによる食材の取得
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) GetFoodItemById(c echo.Context) error {
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}

	foodItem, err := fc.fu.GetFoodItemById(uint(foodItemId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data: foodItem,
	})
}

/**
 * 食材の作成
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) CreateFoodItem(c echo.Context) error {
	foodItem := model.FoodItem{}
	if err := c.Bind(&foodItem); err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid request format",
		})
	}

	// JWTトークンからユーザーIDを取得
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(*jwt.MapClaims)
	userId := uint((*claims)["user_id"].(float64))
	foodItem.UserId = userId

	createdFoodItem, err := fc.fu.CreateFoodItem(foodItem)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusCreated, Response{
		Data:    createdFoodItem,
		Message: "Food item created successfully",
	})
}

/**
 * 食材の更新
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) UpdateFoodItem(c echo.Context) error {
	foodItem := model.FoodItem{}
	if err := c.Bind(&foodItem); err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid request format",
		})
	}

	// IDの存在確認
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}
	foodItem.ID = uint(foodItemId)

	if err := fc.fu.UpdateFoodItem(foodItem); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Data:    foodItem,
		Message: "Food item updated successfully",
	})
}

/**
 * 食材の削除
 * @param c コンテキスト
 * @return エラー
 */
func (fc *foodItemController) DeleteFoodItem(c echo.Context) error {
	id := c.Param("id")
	foodItemId, err := strconv.Atoi(id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{
			Message: "Invalid ID format",
		})
	}

	if err := fc.fu.DeleteFoodItem(uint(foodItemId)); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{
			Message: err.Error(),
		})
	}
	return c.JSON(http.StatusOK, Response{
		Message: "Food item deleted successfully",
	})
}

================
File: go-rest-api/controller/recipe_controller.go
================
package controller

import (
	"go-rest-api/usecase"
	"net/http"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

type IRecipeController interface {
	GetRecipeSuggestions(c echo.Context) error
}

type recipeController struct {
	ru usecase.IRecipeUsecase
}

func NewRecipeController(ru usecase.IRecipeUsecase) IRecipeController {
	return &recipeController{ru}
}

func (rc *recipeController) GetRecipeSuggestions(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(*jwt.MapClaims)
	userId := uint((*claims)["user_id"].(float64))

	// レシピ提案を取得
	suggestions, err := rc.ru.GetRecipeSuggestions(userId)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "レシピの提案に失敗しました",
		})
	}

	return c.JSON(http.StatusOK, []string{suggestions})
}

================
File: go-rest-api/controller/task_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"strconv"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

type ITaskController interface {
	GetAllTasks(c echo.Context) error
	GetTaskById(c echo.Context) error
	CreateTask(c echo.Context) error
	UpdateTask(c echo.Context) error
	DeleteTask(c echo.Context) error
}

type taskController struct {
	tu usecase.ITaskUsecase
}

func NewTaskController(tu usecase.ITaskUsecase) ITaskController {
	return &taskController{tu}
}

func (tc *taskController) GetAllTasks(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]

	tasksRes, err := tc.tu.GetAllTasks(uint(userId.(float64)))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, tasksRes)
}

func (tc *taskController) GetTaskById(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)
	taskRes, err := tc.tu.GetTaskById(uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, taskRes)
}

func (tc *taskController) CreateTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]

	task := model.Task{}
	if err := c.Bind(&task); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	task.UserId = uint(userId.(float64))
	taskRes, err := tc.tu.CreateTask(task)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusCreated, taskRes)
}

func (tc *taskController) UpdateTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)

	task := model.Task{}
	if err := c.Bind(&task); err != nil {
		return c.JSON(http.StatusBadRequest, err.Error())
	}
	taskRes, err := tc.tu.UpdateTask(task, uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.JSON(http.StatusOK, taskRes)
}

func (tc *taskController) DeleteTask(c echo.Context) error {
	user := c.Get("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	userId := claims["user_id"]
	id := c.Param("taskId")
	taskId, _ := strconv.Atoi(id)

	err := tc.tu.DeleteTask(uint(userId.(float64)), uint(taskId))
	if err != nil {
		return c.JSON(http.StatusInternalServerError, err.Error())
	}
	return c.NoContent(http.StatusNoContent)
}

================
File: go-rest-api/controller/user_controller.go
================
package controller

import (
	"go-rest-api/model"
	"go-rest-api/usecase"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
)

type IUserController interface {
	SignUp(c echo.Context) error
	LogIn(c echo.Context) error
	LogOut(c echo.Context) error
	CsrfToken(c echo.Context) error
	VerifyToken(c echo.Context) error
}

type userController struct {
	uu usecase.IUserUsecase
}

func NewUserController(uu usecase.IUserUsecase) IUserController {
	return &userController{uu}
}

func (uc *userController) SignUp(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid request format",
		})
	}
	userRes, err := uc.uu.SignUp(user)
	if err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": err.Error(),
		})
	}
	return c.JSON(http.StatusCreated, userRes)
}

func (uc *userController) LogIn(c echo.Context) error {
	user := model.User{}
	if err := c.Bind(&user); err != nil {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid request format",
		})
	}
	tokenString, err := uc.uu.Login(user)
	if err != nil {
		return c.JSON(http.StatusUnauthorized, echo.Map{
			"message": err.Error(),
		})
	}

	cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = tokenString
	cookie.Expires = time.Now().Add(24 * time.Hour)
	cookie.Path = "/"
	cookie.Domain = "localhost"
	cookie.Secure = true
	cookie.HttpOnly = true
	cookie.SameSite = http.SameSiteNoneMode
	c.SetCookie(cookie)

	return c.JSON(http.StatusOK, echo.Map{
		"message": "Successfully logged in",
	})
}

func (uc *userController) LogOut(c echo.Context) error {
	cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = ""
	cookie.Expires = time.Now()
	cookie.Path = "/"
	cookie.Domain = "localhost"
	cookie.Secure = true
	cookie.HttpOnly = true
	cookie.SameSite = http.SameSiteNoneMode
	c.SetCookie(cookie)

	return c.JSON(http.StatusOK, echo.Map{
		"message": "Successfully logged out",
	})
}

func (uc *userController) CsrfToken(c echo.Context) error {
	token := c.Get("csrf").(string)
	return c.JSON(http.StatusOK, echo.Map{
		"csrf_token": token,
	})
}

func (uc *userController) VerifyToken(c echo.Context) error {
	// JWTミドルウェアによって既に検証されているため、
	// このエンドポイントに到達できた時点で有効なトークン
	return c.JSON(http.StatusOK, echo.Map{
		"message": "Token is valid",
	})
}

================
File: go-rest-api/db/db.go
================
package db

import (
	"fmt"
	"log"
	"os"

	"github.com/joho/godotenv"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func NewDB() *gorm.DB {
	// 常に.envファイルを読み込む
	err := godotenv.Load("../.env")
	if err != nil {
		log.Printf("Warning: .env file not found: %v", err)
	}

	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Tokyo",
		os.Getenv("POSTGRES_HOST"),
		os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PW"),
		os.Getenv("POSTGRES_DB"),
		os.Getenv("POSTGRES_PORT"))

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println("Connected")
	return db
}

func CloseDB(db *gorm.DB) {
	sqlDB, _ := db.DB()
	if err := sqlDB.Close(); err != nil {
		log.Fatalln(err)
	}
}

================
File: go-rest-api/migrate/migrate.go
================
package main

import (
	"fmt"
	"go-rest-api/db"
	"go-rest-api/model"
)

func main() {
	dbConn := db.NewDB()
	defer fmt.Println("Successfully Migrated")
	defer db.CloseDB(dbConn)
	dbConn.AutoMigrate(&model.User{}, &model.Task{}, &model.FoodItem{})
}

================
File: go-rest-api/model/food_item_changes.md
================
# FoodItem モデルの変更点

## 既存の Task モデルからの変更点

### 共通のフィールド（変更なし）

- `ID` (uint): プライマリーキー
- `Title` (string): 名前（Task モデルの Title フィールドを流用）
- `CreatedAt` (time.Time): 作成日時
- `UpdatedAt` (time.Time): 更新日時
- `User` (User): ユーザーとの関連
- `UserId` (uint): ユーザー ID（外部キー）

### 新規追加フィールド

1. `Quantity` (int)

   - 食材の数量を管理
   - `gorm:"not null"` で必須項目として設定

2. `ExpiryDate` (time.Time)
   - 食材の賞味期限を管理
   - `gorm:"not null"` で必須項目として設定

## レスポンス構造体の変更点

### FoodItemResponse

- Task モデルの TaskResponse 構造体をベースに作成
- 新規フィールド（Quantity, ExpiryDate）を追加
- ユーザー情報は除外（TaskResponse と同様）

## マイグレーション

- `migrate.go` に `model.FoodItem{}` を追加
- 既存のマイグレーション機能を活用

## 注意点

- 既存の CRUD 処理を最大限活用
- ユーザーとの関連付けは Task モデルと同様の方式を採用
- 賞味期限による食材管理が可能な設計

================
File: go-rest-api/model/food_item.go
================
package model

import "time"

// FoodItem represents a food item with its details.
type FoodItem struct {
	ID         uint      `json:"id" gorm:"primaryKey"`
	Title      string    `json:"title" gorm:"not null"`       // Reusing the Title field from Task
	Quantity   int       `json:"quantity" gorm:"not null"`    // New field for quantity
	ExpiryDate time.Time `json:"expiry_date" gorm:"not null"` // New field for expiry date
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	User       User      `json:"user" gorm:"foreignKey:UserId; constraint:OnDelete:CASCADE"`
	UserId     uint      `json:"user_id" gorm:"not null"`
}

// FoodItemResponse is the response structure for food items
type FoodItemResponse struct {
	ID         uint      `json:"id"`
	Title      string    `json:"title"`
	Quantity   int       `json:"quantity"`
	ExpiryDate time.Time `json:"expiry_date"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

================
File: go-rest-api/model/task.go
================
package model

import "time"

type Task struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Title     string    `json:"title" gorm:"not null"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	User      User      `json:"user" gorm:"foreignKey:UserId; constraint:OnDelete:CASCADE"`
	UserId    uint      `json:"user_id" gorm:"not null"`
}

type TaskResponse struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Title     string    `json:"title" gorm:"not null"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

================
File: go-rest-api/model/user.go
================
package model

import "time"

type User struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	Email     string    `json:"email" gorm:"unique"`
	Password  string    `json:"password"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type UserResponse struct {
	ID    uint   `json:"id" gorm:"primaryKey"`
	Email string `json:"email" gorm:"unique"`
}

================
File: go-rest-api/repository/food_item_repository.go
================
package repository

import (
	"go-rest-api/model"

	"gorm.io/gorm"
)

type IFoodItemRepository interface {
	GetAllFoodItems(foodItems *[]model.FoodItem) error
	GetFoodItemById(foodItem *model.FoodItem, id uint) error
	CreateFoodItem(foodItem *model.FoodItem) error
	UpdateFoodItem(foodItem *model.FoodItem) error
	DeleteFoodItem(id uint) error
}

type foodItemRepository struct {
	db *gorm.DB
}

func NewFoodItemRepository(db *gorm.DB) IFoodItemRepository {
	return &foodItemRepository{db}
}

func (fr *foodItemRepository) GetAllFoodItems(foodItems *[]model.FoodItem) error {
	if err := fr.db.Find(foodItems).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) GetFoodItemById(foodItem *model.FoodItem, id uint) error {
	if err := fr.db.First(foodItem, id).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) CreateFoodItem(foodItem *model.FoodItem) error {
	if err := fr.db.Create(foodItem).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) UpdateFoodItem(foodItem *model.FoodItem) error {
	if err := fr.db.Save(foodItem).Error; err != nil {
		return err
	}
	return nil
}

func (fr *foodItemRepository) DeleteFoodItem(id uint) error {
	if err := fr.db.Delete(&model.FoodItem{}, id).Error; err != nil {
		return err
	}
	return nil
}

================
File: go-rest-api/repository/task_repositoty.go
================
package repository

import (
	"fmt"
	"go-rest-api/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type ITaskRepository interface {
	GetAllTasks(tasks *[]model.Task, userId uint) error
	GetTaskById(task *model.Task, userId uint, taskId uint) error
	CreateTask(task *model.Task) error
	UpdateTask(task *model.Task, userId uint, taskId uint) error
	DeleteTask(userId uint, taskId uint) error
}

type taskRepository struct {
	db *gorm.DB
}

func NewTaskRepository(db *gorm.DB) ITaskRepository {
	return &taskRepository{db}
}

func (tr *taskRepository) GetAllTasks(tasks *[]model.Task, userId uint) error {
	if err := tr.db.Joins("User").Where("user_id=?", userId).Order("created_at").Find(tasks).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) GetTaskById(task *model.Task, userId uint, taskId uint) error {
	if err := tr.db.Joins("User").Where("user_id=?", userId).First(task, taskId).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) CreateTask(task *model.Task) error {
	if err := tr.db.Create(task).Error; err != nil {
		return err
	}
	return nil
}

func (tr *taskRepository) UpdateTask(task *model.Task, userId uint, taskId uint) error {
	result := tr.db.Model(task).Clauses(clause.Returning{}).Where("id=? AND user_id=?", taskId, userId).Update("title", task.Title)
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected < 1 {
		return fmt.Errorf("object does not exist")
	}
	return nil
}

func (tr *taskRepository) DeleteTask(userId uint, taskId uint) error {
	result := tr.db.Where("id=? AND user_id=?", taskId, userId).Delete(&model.Task{})
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected < 1 {
		return fmt.Errorf("object does not exist")
	}
	return nil
}

================
File: go-rest-api/repository/user_repository.go
================
package repository

import (
	"go-rest-api/model"

	"gorm.io/gorm"
)

type IUserRepository interface {
	GetUserByEmail(user *model.User, email string) error
	CreateUser(user *model.User) error
}

type userRepository struct {
	db *gorm.DB
}

func NewUserRepository(db *gorm.DB) IUserRepository {
	return &userRepository{db}
}

func (ur *userRepository) GetUserByEmail(user *model.User, email string) error {
	if err := ur.db.Where("email=?", email).First(user).Error; err != nil {
		return err
	}
	return nil
}

func (ur *userRepository) CreateUser(user *model.User) error {
	if err := ur.db.Create(user).Error; err != nil {
		return err
	}
	return nil
}

================
File: go-rest-api/router/router.go
================
package router

import (
	"go-rest-api/controller"
	"net/http"
	"os"

	"github.com/golang-jwt/jwt/v5"
	echojwt "github.com/labstack/echo-jwt/v4"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func NewRouter(tc controller.ITaskController, uc controller.IUserController, fc controller.IFoodItemController, rc controller.IRecipeController) *echo.Echo {
	e := echo.New()

	// CORSミドルウェアの設定を修正
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     []string{"http://localhost:3000"},
		AllowMethods:     []string{"*"},
		AllowHeaders:     []string{"*"},
		AllowCredentials: true,
		MaxAge:           86400,
	}))

	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		CookiePath:     "/",
		CookieHTTPOnly: true,
		CookieSameSite: http.SameSiteDefaultMode,
		TokenLookup:    "header:X-CSRF-Token",
	}))

	// 認証関連
	e.POST("/signup", uc.SignUp)
	e.POST("/login", uc.LogIn)
	e.POST("/logout", uc.LogOut)
	e.GET("/csrf", uc.CsrfToken)

	// JWT認証が必要なルート
	api := e.Group("")
	api.Use(echojwt.WithConfig(echojwt.Config{
		NewClaimsFunc: func(c echo.Context) jwt.Claims {
			return new(jwt.MapClaims)
		},
		SigningKey:  []byte(os.Getenv("SECRET")),
		TokenLookup: "cookie:token",
	}))

	// トークン検証エンドポイント
	api.GET("/verify-token", uc.VerifyToken)

	// タスク関連
	tasks := api.Group("/tasks")
	tasks.GET("", tc.GetAllTasks)
	tasks.GET("/:taskId", tc.GetTaskById)
	tasks.POST("", tc.CreateTask)
	tasks.PUT("/:taskId", tc.UpdateTask)
	tasks.DELETE("/:taskId", tc.DeleteTask)

	// 食材関連
	foodItems := api.Group("/food-items")
	foodItems.GET("", fc.GetAllFoodItems)
	foodItems.GET("/:id", fc.GetFoodItemById)
	foodItems.POST("", fc.CreateFoodItem)
	foodItems.PUT("/:id", fc.UpdateFoodItem)
	foodItems.DELETE("/:id", fc.DeleteFoodItem)

	// レシピ関連
	recipes := api.Group("/recipes")
	recipes.GET("/suggestions", rc.GetRecipeSuggestions)

	return e
}

================
File: go-rest-api/services/gemini_service_test.go
================
package services

import (
	"go-rest-api/model"
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestGenerateRecipe(t *testing.T) {
	// APIキーが設定されていない場合はスキップ
	if os.Getenv("GEMINI_API_KEY") == "" {
		t.Skip("GEMINI_API_KEY is not set")
	}

	service, err := NewGeminiService()
	assert.NoError(t, err)

	t.Run("期限切れ間近の食材がある場合", func(t *testing.T) {
		foodItems := []model.FoodItem{
			{
				ID:         1,
				Title:      "トマト",
				Quantity:   2,
				ExpiryDate: time.Now().Add(24 * time.Hour * 3), // 3日後
			},
			{
				ID:         2,
				Title:      "なす",
				Quantity:   1,
				ExpiryDate: time.Now().Add(24 * time.Hour * 5), // 5日後
			},
		}

		recipe, err := service.GenerateRecipe(foodItems)
		assert.NoError(t, err)
		assert.NotEmpty(t, recipe)
		// レシピに食材名が含まれていることを確認
		assert.Contains(t, recipe, "トマト")
		assert.Contains(t, recipe, "なす")
	})

	t.Run("食材が空の場合", func(t *testing.T) {
		_, err := service.GenerateRecipe([]model.FoodItem{})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "食材が指定されていません")
	})

	t.Run("期限切れ間近の食材がない場合", func(t *testing.T) {
		foodItems := []model.FoodItem{
			{
				ID:         1,
				Title:      "りんご",
				Quantity:   3,
				ExpiryDate: time.Now().Add(24 * time.Hour * 30), // 30日後
			},
		}

		_, err := service.GenerateRecipe(foodItems)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "期限切れ間近の食材がありません")
	})
}

func TestNewGeminiService(t *testing.T) {
	t.Run("APIキーが設定されている場合", func(t *testing.T) {
		if os.Getenv("GEMINI_API_KEY") == "" {
			t.Skip("GEMINI_API_KEY is not set")
		}

		service, err := NewGeminiService()
		assert.NoError(t, err)
		assert.NotNil(t, service)
	})

	t.Run("APIキーが設定されていない場合", func(t *testing.T) {
		// 一時的にAPIキーを削除
		originalKey := os.Getenv("GEMINI_API_KEY")
		os.Unsetenv("GEMINI_API_KEY")
		defer os.Setenv("GEMINI_API_KEY", originalKey)

		service, err := NewGeminiService()
		assert.Error(t, err)
		assert.Nil(t, service)
		assert.Contains(t, err.Error(), "GEMINI_API_KEY")
	})
}

================
File: go-rest-api/services/gemini_service.go
================
package services

import (
	"context"
	"fmt"
	"go-rest-api/model"
	"os"
	"strings"
	"time"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

type IGeminiService interface {
	GenerateRecipe(foodItems []model.FoodItem) (string, error)
}

type geminiService struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

func NewGeminiService() (IGeminiService, error) {
	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
	if err != nil {
		return nil, fmt.Errorf("Gemini APIクライアントの作成に失敗しました: %v", err)
	}

	model := client.GenerativeModel("gemini-pro")
	return &geminiService{
		client: client,
		model:  model,
	}, nil
}

func (s *geminiService) GenerateRecipe(foodItems []model.FoodItem) (string, error) {
	if len(foodItems) == 0 {
		return "", fmt.Errorf("食材が指定されていません")
	}

	fmt.Printf("食材リスト: %+v\n", foodItems)

	// 期限切れ間近の食材を抽出
	var expiringItems []model.FoodItem
	for _, item := range foodItems {
		// 現在時刻と賞味期限の差を計算
		timeUntilExpiry := item.ExpiryDate.Sub(time.Now())
		daysUntilExpiry := timeUntilExpiry.Hours() / 24
		fmt.Printf("食材: %s, 期限まで: %.2f日\n", item.Title, daysUntilExpiry)

		// 7日以内に期限切れになる食材を追加
		if daysUntilExpiry >= 0 && daysUntilExpiry <= 7 {
			fmt.Printf("期限切れ間近の食材として追加: %s\n", item.Title)
			expiringItems = append(expiringItems, item)
		}
	}

	// すべての食材を使用
	if len(expiringItems) == 0 {
		fmt.Println("期限切れ間近の食材がないため、すべての食材を使用します")
		expiringItems = foodItems
	} else {
		fmt.Printf("期限切れ間近の食材数: %d\n", len(expiringItems))
	}

	// プロンプトの構築
	var promptBuilder strings.Builder
	promptBuilder.WriteString("以下の食材を使用した、栄養バランスの良いレシピを提案してください：\n\n")
	promptBuilder.WriteString("【食材リスト】\n")
	for _, item := range expiringItems {
		promptBuilder.WriteString(fmt.Sprintf("- %s（%d個）: 賞味期限 %s\n",
			item.Title,
			item.Quantity,
			item.ExpiryDate.Format("2006/01/02")))
	}
	promptBuilder.WriteString("\n【条件】\n")
	promptBuilder.WriteString("1. 上記の食材を優先的に使用すること\n")
	promptBuilder.WriteString("2. 栄養バランスを考慮すること\n")
	promptBuilder.WriteString("3. 調理手順は簡潔に記載すること\n")
	promptBuilder.WriteString("4. 必要な追加食材があれば提案すること\n")
	promptBuilder.WriteString("\n【出力形式】\n")
	promptBuilder.WriteString("1. レシピ名\n")
	promptBuilder.WriteString("2. 材料（2人分）\n")
	promptBuilder.WriteString("3. 調理手順\n")
	promptBuilder.WriteString("4. 栄養バランスの説明\n")

	// Gemini APIにリクエスト
	ctx := context.Background()
	resp, err := s.model.GenerateContent(ctx, genai.Text(promptBuilder.String()))
	if err != nil {
		return "", fmt.Errorf("レシピの生成に失敗しました: %v", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("レシピを生成できませんでした")
	}

	// レスポンスの取得とデバッグ出力
	fmt.Printf("Gemini API レスポンス: %+v\n", resp)

	if len(resp.Candidates) == 0 {
		return "", fmt.Errorf("レスポンスが空です")
	}

	if len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("レスポンスの内容が空です")
	}

	recipe, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		fmt.Printf("予期しないレスポンス形式: %T\n", resp.Candidates[0].Content.Parts[0])
		return "", fmt.Errorf("レスポンスの形式が不正です")
	}

	recipeStr := string(recipe)
	fmt.Printf("生成されたレシピ: %s\n", recipeStr)

	return recipeStr, nil
}

================
File: go-rest-api/usecase/food_item_usecase.go
================
package usecase

import (
	"go-rest-api/model"
	"go-rest-api/repository"
)

type IFoodItemUsecase interface {
	GetAllFoodItems() ([]model.FoodItem, error)
	GetFoodItemById(id uint) (model.FoodItem, error)
	CreateFoodItem(foodItem model.FoodItem) (model.FoodItem, error)
	UpdateFoodItem(foodItem model.FoodItem) error
	DeleteFoodItem(id uint) error
}

type foodItemUsecase struct {
	fr repository.IFoodItemRepository
}

func NewFoodItemUsecase(fr repository.IFoodItemRepository) IFoodItemUsecase {
	return &foodItemUsecase{fr}
}

func (fu *foodItemUsecase) GetAllFoodItems() ([]model.FoodItem, error) {
	foodItems := []model.FoodItem{}
	if err := fu.fr.GetAllFoodItems(&foodItems); err != nil {
		return nil, err
	}
	return foodItems, nil
}

func (fu *foodItemUsecase) GetFoodItemById(id uint) (model.FoodItem, error) {
	foodItem := model.FoodItem{}
	if err := fu.fr.GetFoodItemById(&foodItem, id); err != nil {
		return model.FoodItem{}, err
	}
	return foodItem, nil
}

func (fu *foodItemUsecase) CreateFoodItem(foodItem model.FoodItem) (model.FoodItem, error) {
	if err := fu.fr.CreateFoodItem(&foodItem); err != nil {
		return model.FoodItem{}, err
	}
	return foodItem, nil
}

func (fu *foodItemUsecase) UpdateFoodItem(foodItem model.FoodItem) error {
	if err := fu.fr.UpdateFoodItem(&foodItem); err != nil {
		return err
	}
	return nil
}

func (fu *foodItemUsecase) DeleteFoodItem(id uint) error {
	if err := fu.fr.DeleteFoodItem(id); err != nil {
		return err
	}
	return nil
}

================
File: go-rest-api/usecase/recipe_usecase_test.go
================
package usecase

import (
	"go-rest-api/model"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type MockFoodItemRepository struct {
	mock.Mock
}

func (m *MockFoodItemRepository) GetAllFoodItems(foodItems *[]model.FoodItem) error {
	args := m.Called(foodItems)
	if items, ok := args.Get(0).([]model.FoodItem); ok {
		*foodItems = items
	}
	return args.Error(1)
}

func (m *MockFoodItemRepository) GetFoodItemById(foodItem *model.FoodItem, id uint) error {
	args := m.Called(foodItem, id)
	return args.Error(0)
}

func (m *MockFoodItemRepository) CreateFoodItem(foodItem *model.FoodItem) error {
	args := m.Called(foodItem)
	return args.Error(0)
}

func (m *MockFoodItemRepository) UpdateFoodItem(foodItem *model.FoodItem) error {
	args := m.Called(foodItem)
	return args.Error(0)
}

func (m *MockFoodItemRepository) DeleteFoodItem(id uint) error {
	args := m.Called(id)
	return args.Error(0)
}

type MockGeminiService struct {
	mock.Mock
}

func (m *MockGeminiService) GenerateRecipe(foodItems []model.FoodItem) (string, error) {
	args := m.Called(foodItems)
	return args.String(0), args.Error(1)
}

func TestGetRecipeSuggestions(t *testing.T) {
	t.Run("期限切れ間近の食材がある場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// テストデータ
		foodItems := []model.FoodItem{
			{
				ID:         1,
				Title:      "トマト",
				Quantity:   2,
				ExpiryDate: time.Now().Add(24 * time.Hour * 3), // 3日後
			},
		}
		expectedRecipe := "トマトを使用したレシピ..."

		// モックの設定
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Run(func(args mock.Arguments) {
				arg := args.Get(0).(*[]model.FoodItem)
				*arg = foodItems
			}).
			Return(foodItems, nil)

		mockGemini.On("GenerateRecipe", foodItems).
			Return(expectedRecipe, nil)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.NoError(t, err)
		assert.Equal(t, expectedRecipe, recipe)
		mockRepo.AssertExpectations(t)
		mockGemini.AssertExpectations(t)
	})

	t.Run("食材が存在しない場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// モックの設定
		var emptyFoodItems []model.FoodItem
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Run(func(args mock.Arguments) {
				arg := args.Get(0).(*[]model.FoodItem)
				*arg = emptyFoodItems
			}).
			Return(emptyFoodItems, nil)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.Error(t, err)
		assert.Empty(t, recipe)
		assert.Contains(t, err.Error(), "食材が登録されていません")
		mockRepo.AssertExpectations(t)
	})

	t.Run("リポジトリでエラーが発生した場合", func(t *testing.T) {
		mockRepo := new(MockFoodItemRepository)
		mockGemini := new(MockGeminiService)
		usecase := NewRecipeUsecase(mockRepo, mockGemini)

		// モックの設定
		mockRepo.On("GetAllFoodItems", mock.AnythingOfType("*[]model.FoodItem")).
			Return([]model.FoodItem{}, assert.AnError)

		// テスト実行
		recipe, err := usecase.GetRecipeSuggestions(1)

		// アサーション
		assert.Error(t, err)
		assert.Empty(t, recipe)
		mockRepo.AssertExpectations(t)
	})
}

================
File: go-rest-api/usecase/recipe_usecase.go
================
package usecase

import (
	"fmt"
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/services"
)

type IRecipeUsecase interface {
	GetRecipeSuggestions(userId uint) (string, error)
}

type recipeUsecase struct {
	fr repository.IFoodItemRepository
	gs services.IGeminiService
}

func NewRecipeUsecase(fr repository.IFoodItemRepository, gs services.IGeminiService) IRecipeUsecase {
	return &recipeUsecase{fr, gs}
}

func (ru *recipeUsecase) GetRecipeSuggestions(userId uint) (string, error) {
	// ユーザーの食材一覧を取得
	var foodItems []model.FoodItem
	if err := ru.fr.GetAllFoodItems(&foodItems); err != nil {
		return "", fmt.Errorf("食材の取得に失敗しました: %v", err)
	}

	// 食材が存在しない場合は適切なメッセージを返す
	if len(foodItems) == 0 {
		return "食材が登録されていません。食材を追加してからレシピを取得してください。", nil
	}

	// レシピを生成
	recipe, err := ru.gs.GenerateRecipe(foodItems)
	if err != nil {
		// Geminiサービスのエラーをログに出力
		fmt.Printf("Geminiサービスエラー: %v\n", err)
		return "レシピの生成中にエラーが発生しました。しばらく待ってから再試行してください。", nil
	}

	if recipe == "" {
		return "レシピを生成できませんでした。別の食材を試してみてください。", nil
	}

	return recipe, nil
}

================
File: go-rest-api/usecase/task_usecase.go
================
package usecase

import (
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/validator"
)

type ITaskUsecase interface {
	GetAllTasks(userId uint) ([]model.TaskResponse, error)
	GetTaskById(userId uint, taskId uint) (model.TaskResponse, error)
	CreateTask(task model.Task) (model.TaskResponse, error)
	UpdateTask(task model.Task, userId uint, taskId uint) (model.TaskResponse, error)
	DeleteTask(userId uint, taskId uint) error
}

type taskUsecase struct {
	tr repository.ITaskRepository
	tv validator.ITaskValidator
}

func NewTaskUsecase(tr repository.ITaskRepository, tv validator.ITaskValidator) ITaskUsecase {
	return &taskUsecase{tr, tv}
}

func (tu *taskUsecase) GetAllTasks(userId uint) ([]model.TaskResponse, error) {
	tasks := []model.Task{}
	if err := tu.tr.GetAllTasks(&tasks, userId); err != nil {
		return nil, err
	}
	resTasks := []model.TaskResponse{}
	for _, v := range tasks {
		t := model.TaskResponse{
			ID:        v.ID,
			Title:     v.Title,
			CreatedAt: v.CreatedAt,
			UpdatedAt: v.UpdatedAt,
		}
		resTasks = append(resTasks, t)
	}
	return resTasks, nil
}

func (tu *taskUsecase) GetTaskById(userId uint, taskId uint) (model.TaskResponse, error) {
	task := model.Task{}
	if err := tu.tr.GetTaskById(&task, userId, taskId); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) CreateTask(task model.Task) (model.TaskResponse, error) {
	if err := tu.tv.TaskValidate(task); err != nil {
		return model.TaskResponse{}, err
	}
	if err := tu.tr.CreateTask(&task); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) UpdateTask(task model.Task, userId uint, taskId uint) (model.TaskResponse, error) {
	if err := tu.tv.TaskValidate(task); err != nil {
		return model.TaskResponse{}, err
	}
	if err := tu.tr.UpdateTask(&task, userId, taskId); err != nil {
		return model.TaskResponse{}, err
	}
	resTask := model.TaskResponse{
		ID:        task.ID,
		Title:     task.Title,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
	}
	return resTask, nil
}

func (tu *taskUsecase) DeleteTask(userId uint, taskId uint) error {
	if err := tu.tr.DeleteTask(userId, taskId); err != nil {
		return err
	}
	return nil
}

================
File: go-rest-api/usecase/user_usecase.go
================
package usecase

import (
	"errors"
	"go-rest-api/model"
	"go-rest-api/repository"
	"go-rest-api/validator"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

type IUserUsecase interface {
	SignUp(user model.User) (model.UserResponse, error)
	Login(user model.User) (string, error)
}

type userUsecase struct {
	ur repository.IUserRepository
	uv validator.IUserValidator
}

func NewUserUsecase(ur repository.IUserRepository, uv validator.IUserValidator) IUserUsecase {
	return &userUsecase{ur, uv}
}

func (uu *userUsecase) SignUp(user model.User) (model.UserResponse, error) {
	if err := uu.uv.UserValidate(user); err != nil {
		return model.UserResponse{}, err
	}

	// メールアドレスの重複チェック
	var existingUser model.User
	if err := uu.ur.GetUserByEmail(&existingUser, user.Email); err == nil {
		return model.UserResponse{}, errors.New("email already exists")
	}

	hash, err := bcrypt.GenerateFromPassword([]byte(user.Password), 10)
	if err != nil {
		return model.UserResponse{}, errors.New("failed to hash password")
	}

	newUser := model.User{Email: user.Email, Password: string(hash)}
	if err := uu.ur.CreateUser(&newUser); err != nil {
		return model.UserResponse{}, errors.New("failed to create user")
	}

	resUser := model.UserResponse{
		ID:    newUser.ID,
		Email: newUser.Email,
	}
	return resUser, nil
}

func (uu *userUsecase) Login(user model.User) (string, error) {
	if err := uu.uv.UserValidate(user); err != nil {
		return "", err
	}

	storedUser := model.User{}
	if err := uu.ur.GetUserByEmail(&storedUser, user.Email); err != nil {
		return "", errors.New("invalid email or password")
	}

	err := bcrypt.CompareHashAndPassword([]byte(storedUser.Password), []byte(user.Password))
	if err != nil {
		return "", errors.New("invalid email or password")
	}

	// JWTトークンの生成
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": storedUser.ID,
		"email":   storedUser.Email,
		"exp":     time.Now().Add(time.Hour * 12).Unix(),
	})

	tokenString, err := token.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		return "", errors.New("failed to generate token")
	}

	return tokenString, nil
}

================
File: go-rest-api/validator/task_validator.go
================
package validator

import (
	"go-rest-api/model"

	validation "github.com/go-ozzo/ozzo-validation/v4"
)

type ITaskValidator interface {
	TaskValidate(task model.Task) error
}

type taskValidator struct{}

func NewTaskValidator() ITaskValidator {
	return &taskValidator{}
}

func (tv *taskValidator) TaskValidate(task model.Task) error {
	return validation.ValidateStruct(&task,
		validation.Field(
			&task.Title,
			validation.Required.Error("title is required"),
			validation.RuneLength(1, 10).Error("limited max 10 char"),
		),
	)
}

================
File: go-rest-api/validator/user_validator.go
================
package validator

import (
	"go-rest-api/model"

	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/go-ozzo/ozzo-validation/v4/is"
)

type IUserValidator interface {
	UserValidate(user model.User) error
}

type userValidator struct{}

func NewUserValidator() IUserValidator {
	return &userValidator{}
}

func (uv *userValidator) UserValidate(user model.User) error {
	return validation.ValidateStruct(&user,
		validation.Field(
			&user.Email,
			validation.Required.Error("email is required"),
			validation.RuneLength(1, 30).Error("limited max 30 char"),
			is.Email.Error("is not valid email format"),
		),
		validation.Field(
			&user.Password,
			validation.Required.Error("password is required"),
			validation.RuneLength(6, 30).Error("limited min 6 max 30 char"),
		),
	)
}

================
File: go-rest-api/docker-compose.yml
================
services:
  db:
    image: postgres:15-alpine
    container_name: smart_pantry_db
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PW:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-smart_pantry}
      TZ: "Asia/Tokyo"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local

================
File: go-rest-api/go.mod
================
module go-rest-api

go 1.23.4

require (
	github.com/go-ozzo/ozzo-validation/v4 v4.3.0
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/generative-ai-go v0.19.0
	github.com/joho/godotenv v1.5.1
	github.com/labstack/echo-jwt/v4 v4.3.0
	github.com/labstack/echo/v4 v4.13.3
	github.com/stretchr/testify v1.10.0
	golang.org/x/crypto v0.32.0
	google.golang.org/api v0.218.0
	gorm.io/driver/postgres v1.5.11
	gorm.io/gorm v1.25.12
)

require (
	cloud.google.com/go v0.115.0 // indirect
	cloud.google.com/go/ai v0.8.0 // indirect
	cloud.google.com/go/auth v0.14.0 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.7 // indirect
	cloud.google.com/go/compute/metadata v0.6.0 // indirect
	cloud.google.com/go/longrunning v0.5.7 // indirect
	github.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/googleapis/gax-go/v2 v2.14.1 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.5.5 // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rogpeppe/go-internal v1.13.1 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect
	go.opentelemetry.io/otel v1.31.0 // indirect
	go.opentelemetry.io/otel/metric v1.31.0 // indirect
	go.opentelemetry.io/otel/trace v1.31.0 // indirect
	golang.org/x/net v0.34.0 // indirect
	golang.org/x/oauth2 v0.25.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250115164207-1a7da9e5054f // indirect
	google.golang.org/grpc v1.69.4 // indirect
	google.golang.org/protobuf v1.36.3 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: go-rest-api/main.go
================
package main

import (
	"go-rest-api/controller"
	"go-rest-api/db"
	"go-rest-api/repository"
	"go-rest-api/router"
	"go-rest-api/services"
	"go-rest-api/usecase"
	"go-rest-api/validator"
	"log"
)

func main() {
	db := db.NewDB()
	userValidator := validator.NewUserValidator()
	taskValidator := validator.NewTaskValidator()

	// リポジトリの初期化
	userRepository := repository.NewUserRepository(db)
	taskRepository := repository.NewTaskRepository(db)
	foodItemRepository := repository.NewFoodItemRepository(db)

	// サービスの初期化
	geminiService, err := services.NewGeminiService()
	if err != nil {
		log.Fatalf("Failed to initialize Gemini service: %v", err)
	}

	// ユースケースの初期化
	userUsecase := usecase.NewUserUsecase(userRepository, userValidator)
	taskUsecase := usecase.NewTaskUsecase(taskRepository, taskValidator)
	foodItemUsecase := usecase.NewFoodItemUsecase(foodItemRepository)
	recipeUsecase := usecase.NewRecipeUsecase(foodItemRepository, geminiService)

	// コントローラーの初期化
	userController := controller.NewUserController(userUsecase)
	taskController := controller.NewTaskController(taskUsecase)
	foodItemController := controller.NewFoodItemController(foodItemUsecase)
	recipeController := controller.NewRecipeController(recipeUsecase)

	// ルーターの設定
	e := router.NewRouter(taskController, userController, foodItemController, recipeController)
	e.Logger.Fatal(e.Start(":8080"))
}

================
File: react-todo/public/index.html
================
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Smart Pantry - スマートな食材管理アプリ"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Outfit:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <title>Smart Pantry</title>
    <style>
      body {
        margin: 0;
        font-family: 'Noto Sans JP', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

================
File: react-todo/public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: react-todo/public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: react-todo/src/components/__tests__/FoodItem.test.tsx
================
import { render, screen } from '@testing-library/react'
import { FoodItem } from '../FoodItem'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
})

const mockFoodItem = {
  id: 1,
  title: 'トマト',
  quantity: 3,
  expiryDate: new Date('2025-02-05'), // 1週間後
}

const renderWithProvider = (component: React.ReactElement) => {
  return render(
    <QueryClientProvider client={queryClient}>{component}</QueryClientProvider>
  )
}

describe('FoodItem', () => {
  it('食材の基本情報を表示', () => {
    renderWithProvider(<FoodItem foodItem={mockFoodItem} />)
    expect(screen.getByText('トマト')).toBeInTheDocument()
    expect(screen.getByText('数量: 3')).toBeInTheDocument()
    expect(screen.getByText(/2025年2月5日/)).toBeInTheDocument()
  })

  it('期限切れ間近の食材は警告表示', () => {
    const warningItem = {
      ...mockFoodItem,
      expiryDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3日後
    }
    renderWithProvider(<FoodItem foodItem={warningItem} />)
    expect(screen.getByText(/期限切れまで3日/)).toBeInTheDocument()
  })

  it('期限切れの食材は赤色表示', () => {
    const expiredItem = {
      ...mockFoodItem,
      expiryDate: new Date(Date.now() - 24 * 60 * 60 * 1000), // 1日前
    }
    renderWithProvider(<FoodItem foodItem={expiredItem} />)
    const titleElement = screen.getByText('トマト')
    expect(titleElement).toHaveClass('text-red-600')
  })
})

================
File: react-todo/src/components/__tests__/FoodList.test.tsx
================
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { FoodList } from '../FoodList'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useQueryFoodItems } from '../../hooks/useQueryFoodItems'
import { useMutateFoodItem } from '../../hooks/useMutateFoodItem'

jest.mock('../../hooks/useQueryFoodItems')
jest.mock('../../hooks/useMutateFoodItem')

const mockUseQueryFoodItems = useQueryFoodItems as jest.MockedFunction<
  typeof useQueryFoodItems
>
const mockUseMutateFoodItem = useMutateFoodItem as jest.MockedFunction<
  typeof useMutateFoodItem
>

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
})

const mockFoodItems = [
  {
    id: 1,
    title: 'トマト',
    quantity: 3,
    expiryDate: new Date('2025-02-05'),
  },
  {
    id: 2,
    title: 'きゅうり',
    quantity: 2,
    expiryDate: new Date('2025-02-10'),
  },
]

const renderWithProvider = (component: React.ReactElement) => {
  return render(
    <QueryClientProvider client={queryClient}>{component}</QueryClientProvider>
  )
}

describe('FoodList', () => {
  beforeEach(() => {
    mockUseQueryFoodItems.mockReturnValue({
      data: mockFoodItems,
      isLoading: false,
      error: null,
    } as any)

    mockUseMutateFoodItem.mockReturnValue({
      createFoodItemMutation: {
        mutate: jest.fn(),
      },
    } as any)
  })

  it('食材一覧を表示', () => {
    renderWithProvider(<FoodList />)
    expect(screen.getByText('トマト')).toBeInTheDocument()
    expect(screen.getByText('きゅうり')).toBeInTheDocument()
  })

  it('新しい食材を追加できる', async () => {
    const mockCreateMutate = jest.fn()
    mockUseMutateFoodItem.mockReturnValue({
      createFoodItemMutation: {
        mutate: mockCreateMutate,
      },
    } as any)

    renderWithProvider(<FoodList />)

    // フォームに入力
    fireEvent.change(screen.getByLabelText('食材名'), {
      target: { value: 'なす' },
    })
    fireEvent.change(screen.getByLabelText('数量'), {
      target: { value: '4' },
    })
    const today = new Date()
    fireEvent.change(screen.getByLabelText('賞味期限'), {
      target: { value: today.toISOString().split('T')[0] },
    })

    // フォームを送信
    fireEvent.submit(screen.getByRole('button', { name: '追加' }))

    await waitFor(() => {
      expect(mockCreateMutate).toHaveBeenCalledWith({
        title: 'なす',
        quantity: 4,
        expiryDate: expect.any(Date),
      })
    })
  })

  it('ローディング中はローディングインジケータを表示', () => {
    mockUseQueryFoodItems.mockReturnValue({
      data: undefined,
      isLoading: true,
      error: null,
    } as any)

    renderWithProvider(<FoodList />)
    expect(screen.getByRole('progressbar')).toBeInTheDocument()
  })

  it('エラー時はエラーメッセージを表示', () => {
    mockUseQueryFoodItems.mockReturnValue({
      data: undefined,
      isLoading: false,
      error: new Error('エラーが発生しました'),
    } as any)

    renderWithProvider(<FoodList />)
    expect(screen.getByText(/エラーが発生しました/)).toBeInTheDocument()
  })
})

================
File: react-todo/src/components/__tests__/RecipeSuggestions.test.tsx
================
import { render, screen, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { RecipeSuggestions } from '../RecipeSuggestions'
import { useQueryRecipe } from '../../hooks/useQueryRecipe'

jest.mock('../../hooks/useQueryRecipe')
const mockUseQueryRecipe = useQueryRecipe as jest.MockedFunction<
  typeof useQueryRecipe
>

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
})

const renderWithProvider = (component: React.ReactElement) => {
  return render(
    <QueryClientProvider client={queryClient}>{component}</QueryClientProvider>
  )
}

describe('RecipeSuggestions', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('ローディング中はローディングインジケータを表示', () => {
    mockUseQueryRecipe.mockReturnValue({
      data: undefined,
      isLoading: true,
      error: null,
      isError: false,
    } as any)

    renderWithProvider(<RecipeSuggestions />)
    expect(screen.getByRole('progressbar')).toBeInTheDocument()
  })

  it('エラー時はエラーメッセージを表示', () => {
    mockUseQueryRecipe.mockReturnValue({
      data: undefined,
      isLoading: false,
      error: new Error('エラーが発生しました'),
      isError: true,
    } as any)

    renderWithProvider(<RecipeSuggestions />)
    expect(screen.getByText(/レシピの取得に失敗しました/)).toBeInTheDocument()
  })

  it('データがない場合は適切なメッセージを表示', () => {
    mockUseQueryRecipe.mockReturnValue({
      data: undefined,
      isLoading: false,
      error: null,
      isError: false,
    } as any)

    renderWithProvider(<RecipeSuggestions />)
    expect(
      screen.getByText(/期限切れ間近の食材がありません/)
    ).toBeInTheDocument()
  })

  it('レシピデータを正しく表示', async () => {
    const mockRecipe = 'テストレシピの内容'
    mockUseQueryRecipe.mockReturnValue({
      data: mockRecipe,
      isLoading: false,
      error: null,
      isError: false,
    } as any)

    renderWithProvider(<RecipeSuggestions />)

    await waitFor(() => {
      expect(screen.getByText('おすすめレシピ')).toBeInTheDocument()
      expect(screen.getByText(mockRecipe)).toBeInTheDocument()
    })
  })
})

================
File: react-todo/src/components/Auth.tsx
================
import { useState, FormEvent } from 'react'
import { useMutateAuth } from '../hooks/useMutateAuth'
import { useError } from '../hooks/useError'
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  IconButton,
  CircularProgress,
  Snackbar,
  Alert,
} from '@mui/material'
import {
  KitchenOutlined,
  SwapHoriz as SwapHorizIcon,
} from '@mui/icons-material'

export const Auth = () => {
  const [email, setEmail] = useState('')
  const [pw, setPw] = useState('')
  const [isLogin, setIsLogin] = useState(true)
  const { loginMutation, registerMutation } = useMutateAuth()
  const { errorMessage, setErrorMessage } = useError()

  const submitAuthHandler = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (!email || !pw) {
      setErrorMessage('メールアドレスとパスワードを入力してください')
      return
    }

    try {
      if (isLogin) {
        await loginMutation.mutateAsync({
          email: email,
          password: pw,
        })
      } else {
        await registerMutation
          .mutateAsync({
            email: email,
            password: pw,
          })
          .then(() =>
            loginMutation.mutate({
              email: email,
              password: pw,
            })
          )
      }
    } catch (error) {
      console.error('Auth error:', error)
    }
  }

  const isLoading = loginMutation.isPending || registerMutation.isPending

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper
          elevation={3}
          sx={{
            padding: 4,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            width: '100%',
          }}
        >
          <Box
            sx={{
              display: 'flex',
              flexDirection: { xs: 'column', sm: 'row' },
              alignItems: 'center',
              gap: { xs: 1, sm: 2 },
              mb: 3,
            }}
          >
            <KitchenOutlined
              sx={{
                fontSize: { xs: 32, sm: 40 },
                color: 'primary.main',
              }}
            />
            <Typography
              component="h1"
              variant="h4"
              fontWeight="bold"
              sx={{
                fontSize: { xs: '1.5rem', sm: '2rem' },
                letterSpacing: 0.5,
                color: 'primary.main',
                textAlign: 'center',
                lineHeight: 1.2,
              }}
            >
              Smart Pantry
            </Typography>
          </Box>

          <Typography component="h2" variant="h6" sx={{ mb: 3 }}>
            {isLogin ? 'ログイン' : '新規アカウント作成'}
          </Typography>

          <Box
            component="form"
            onSubmit={submitAuthHandler}
            sx={{ width: '100%' }}
          >
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="メールアドレス"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              disabled={isLoading}
              error={!!errorMessage && errorMessage.includes('メールアドレス')}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="パスワード"
              type="password"
              id="password"
              autoComplete="current-password"
              value={pw}
              onChange={(e) => setPw(e.target.value)}
              disabled={isLoading}
              error={!!errorMessage && errorMessage.includes('パスワード')}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2, position: 'relative', height: 36.5 }}
              disabled={!email || !pw || isLoading}
            >
              {isLoading ? (
                <CircularProgress
                  size={24}
                  sx={{
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    marginTop: '-12px',
                    marginLeft: '-12px',
                  }}
                />
              ) : isLogin ? (
                'ログイン'
              ) : (
                '登録'
              )}
            </Button>
          </Box>

          <Box sx={{ mt: 1, display: 'flex', alignItems: 'center' }}>
            <Typography variant="body2" color="text.secondary">
              {isLogin
                ? 'アカウントをお持ちでない方は'
                : 'アカウントをお持ちの方は'}
            </Typography>
            <IconButton
              onClick={() => {
                setIsLogin(!isLogin)
                setErrorMessage('')
              }}
              size="small"
              sx={{ ml: 1 }}
              disabled={isLoading}
            >
              <SwapHorizIcon />
            </IconButton>
          </Box>
        </Paper>
      </Box>

      <Snackbar
        open={!!errorMessage}
        autoHideDuration={6000}
        onClose={() => setErrorMessage('')}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setErrorMessage('')}
          severity="error"
          sx={{ width: '100%' }}
        >
          {errorMessage}
        </Alert>
      </Snackbar>
    </Container>
  )
}

================
File: react-todo/src/components/FoodItem.tsx
================
import React, { FC } from 'react'
import { Box, Button, Typography, Paper } from '@mui/material'
import { FoodItem as FoodItemType } from '../types'
import { useMutateFoodItem } from '../hooks/useMutateFoodItem'

interface Props {
  foodItem: FoodItemType
}

export const FoodItem: FC<Props> = ({ foodItem }) => {
  const { deleteFoodItemMutation } = useMutateFoodItem()

  const getDaysUntilExpiry = (expiryDateStr: string): number => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const expiry = new Date(expiryDateStr)
    expiry.setHours(0, 0, 0, 0)
    return Math.ceil((expiry.getTime() - today.getTime()) / (1000 * 3600 * 24))
  }

  const isExpired = (expiryDateStr: string) => {
    return getDaysUntilExpiry(expiryDateStr) < 0
  }

  const isExpiringSoon = (expiryDateStr: string) => {
    const daysUntilExpiry = getDaysUntilExpiry(expiryDateStr)
    return daysUntilExpiry >= 0 && daysUntilExpiry <= 7
  }

  const getStatusColor = () => {
    if (isExpired(foodItem.expiry_date)) {
      return 'error.main'
    }
    if (isExpiringSoon(foodItem.expiry_date)) {
      return 'warning.main'
    }
    return 'info.main'
  }

  return (
    <Paper
      component="li"
      elevation={0}
      sx={{
        p: 2.5,
        mb: 2,
        borderRadius: 2,
        background: 'linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)',
        border: '1px solid rgba(0, 0, 0, 0.08)',
        position: 'relative',
        overflow: 'hidden',
        transition: 'transform 0.2s ease-in-out',
        listStyle: 'none',
        '&:hover': {
          transform: 'translateY(-2px)',
        },
      }}
    >
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        }}
      >
        <Box>
          <Typography
            sx={{
              fontSize: '1rem',
              fontWeight: 500,
              color: 'rgba(0, 0, 0, 0.87)',
              mb: 1,
              display: 'flex',
              alignItems: 'center',
              gap: 1,
              '&::before': {
                content: '""',
                width: 8,
                height: 8,
                borderRadius: '50%',
                bgcolor: getStatusColor(),
                flexShrink: 0,
              },
            }}
          >
            {foodItem.title}
          </Typography>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              gap: 3,
              color: 'rgba(0, 0, 0, 0.6)',
            }}
          >
            <Typography
              variant="body2"
              sx={{
                fontSize: '0.875rem',
                display: 'flex',
                alignItems: 'center',
              }}
            >
              数量: {foodItem.quantity}
            </Typography>
            <Typography
              variant="body2"
              sx={{
                fontSize: '0.875rem',
                display: 'flex',
                alignItems: 'center',
              }}
            >
              期限: {new Date(foodItem.expiry_date).toLocaleDateString('ja-JP')}
            </Typography>
            <Typography
              variant="body2"
              sx={{
                fontSize: '0.875rem',
                color: getStatusColor(),
                fontWeight: 500,
                display: 'flex',
                alignItems: 'center',
              }}
            >
              残り{getDaysUntilExpiry(foodItem.expiry_date)}日
            </Typography>
          </Box>
        </Box>
        <Button
          onClick={() => deleteFoodItemMutation.mutate(foodItem.id)}
          variant="text"
          sx={{
            minWidth: 'auto',
            color: 'rgba(0, 0, 0, 0.6)',
            fontSize: '0.875rem',
            fontWeight: 500,
            textTransform: 'none',
            position: 'relative',
            '&:hover': {
              backgroundColor: 'transparent',
              '&::after': {
                width: '100%',
              },
            },
            '&::after': {
              content: '""',
              position: 'absolute',
              bottom: 6,
              left: 0,
              width: 0,
              height: '1px',
              backgroundColor: 'rgba(0, 0, 0, 0.6)',
              transition: 'width 0.2s ease-in-out',
            },
          }}
        >
          削除
        </Button>
      </Box>
    </Paper>
  )
}

================
File: react-todo/src/components/FoodItemForm.tsx
================
import React, { FC } from 'react'
import { useFoodItemForm } from '../hooks/useFoodItemForm'
import {
  TextField,
  Button,
  Box,
  FormControl,
  InputLabel,
  Input,
  InputAdornment,
} from '@mui/material'
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider'
import { DatePicker } from '@mui/x-date-pickers/DatePicker'
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns'
import jaLocale from 'date-fns/locale/ja'

/**
 * 食材登録フォームコンポーネント
 *
 * このコンポーネントは以下の機能を提供します：
 * - 食材名の入力
 * - 数量の入力（1以上の整数）
 * - 賞味期限の入力（日付選択）
 * - フォームの送信処理
 *
 * フォームの状態管理とバリデーション処理は useFoodItemForm カスタムフックに
 * 分離されており、UIのみに集中しています。
 */
export const FoodItemForm: FC = () => {
  // フォームの状態と操作メソッドを取得
  const {
    title,
    quantity,
    expiryDate,
    handleTitleChange,
    handleQuantityChange,
    handleExpiryDateChange,
    handleSubmit,
  } = useFoodItemForm()

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ mb: 4 }}>
      {/* 食材名入力フィールド */}
      <FormControl fullWidth sx={{ mb: 2 }}>
        <TextField
          label="食材名"
          value={title}
          onChange={handleTitleChange}
          required
          inputProps={{
            'aria-label': '食材名入力',
          }}
        />
      </FormControl>

      {/* 数量入力フィールド */}
      <FormControl fullWidth sx={{ mb: 2 }}>
        <InputLabel htmlFor="quantity">数量</InputLabel>
        <Input
          id="quantity"
          type="number"
          value={quantity}
          onChange={handleQuantityChange}
          endAdornment={<InputAdornment position="end">個</InputAdornment>}
          inputProps={{
            min: 1,
            'aria-label': '数量入力',
          }}
          required
        />
      </FormControl>

      {/* 賞味期限入力フィールド */}
      <FormControl fullWidth sx={{ mb: 2 }}>
        <LocalizationProvider
          dateAdapter={AdapterDateFns}
          adapterLocale={jaLocale}
        >
          <DatePicker
            label="賞味期限"
            value={expiryDate}
            onChange={handleExpiryDateChange}
            format="yyyy/MM/dd"
            slotProps={{
              textField: {
                'aria-label': '賞味期限選択',
              },
            }}
          />
        </LocalizationProvider>
      </FormControl>

      {/* 送信ボタン */}
      <Button
        variant="contained"
        color="primary"
        type="submit"
        fullWidth
        sx={{ mt: 2 }}
        aria-label="食材を追加"
      >
        追加
      </Button>
    </Box>
  )
}

================
File: react-todo/src/components/FoodList.tsx
================
import React, { FC, useState } from 'react'
import { useQueryFoodItems } from '../hooks/useQueryFoodItems'
import { useMutateFoodItem } from '../hooks/useMutateFoodItem'
import { FoodItem as FoodItemComponent } from './FoodItem'
import { FoodItem } from '../types'

export const FoodList: FC = () => {
  const [title, setTitle] = useState('')
  const [quantity, setQuantity] = useState(1)
  const [expiryDate, setExpiryDate] = useState('')
  const { data: foodItems } = useQueryFoodItems() as { data: FoodItem[] }
  const { createFoodItemMutation } = useMutateFoodItem()

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (title && quantity && expiryDate) {
      createFoodItemMutation.mutate({
        title,
        quantity,
        expiry_date: expiryDate, // Date型からstring型に変更
      })
      setTitle('')
      setQuantity(1)
      setExpiryDate('')
    }
  }

  return (
    <div className="p-6">
      <form onSubmit={handleSubmit} className="mb-6 space-y-4">
        <div>
          <label
            htmlFor="title"
            className="block text-sm font-medium text-gray-700"
          >
            食材名
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            required
          />
        </div>
        <div>
          <label
            htmlFor="quantity"
            className="block text-sm font-medium text-gray-700"
          >
            数量
          </label>
          <input
            type="number"
            id="quantity"
            value={quantity}
            onChange={(e) => setQuantity(parseInt(e.target.value))}
            min="1"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            required
          />
        </div>
        <div>
          <label
            htmlFor="expiryDate"
            className="block text-sm font-medium text-gray-700"
          >
            賞味期限
          </label>
          <input
            type="date"
            id="expiryDate"
            value={expiryDate}
            onChange={(e) => setExpiryDate(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            required
          />
        </div>
        <button
          type="submit"
          className="w-full px-4 py-2 text-white bg-indigo-600 rounded hover:bg-indigo-700 focus:outline-none"
        >
          追加
        </button>
      </form>

      <div>
        <h2 className="text-xl font-bold mb-4">食材一覧</h2>
        <ul>
          {foodItems?.map((foodItem: FoodItem) => (
            <FoodItemComponent key={foodItem.id} foodItem={foodItem} />
          ))}
        </ul>
      </div>
    </div>
  )
}

================
File: react-todo/src/components/Layout.tsx
================
import React, { FC, ReactNode } from 'react'
import { useNavigate, useLocation } from 'react-router-dom'
import {
  Box,
  Drawer,
  AppBar,
  Toolbar,
  List,
  Typography,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Button,
} from '@mui/material'
import {
  Dashboard as DashboardIcon,
  Kitchen as KitchenIcon,
  Restaurant as RestaurantIcon,
  Inventory as InventoryIcon,
  Logout as LogoutIcon,
} from '@mui/icons-material'

const drawerWidth = 240

interface Props {
  children: ReactNode
}

export const Layout: FC<Props> = ({ children }) => {
  const navigate = useNavigate()
  const location = useLocation()
  const isAuthenticated = true // TODO: 認証状態の管理を実装

  const handleLogout = () => {
    // TODO: 認証状態のクリアを実装
    navigate('/login')
  }

  const menuItems = [
    {
      text: 'ダッシュボード',
      path: '/dashboard',
      icon: <DashboardIcon />,
      requiresAuth: true,
    },
    {
      text: 'パントリー管理',
      path: '/pantry',
      icon: <KitchenIcon />,
      requiresAuth: true,
    },
    {
      text: '食材管理',
      path: '/food',
      icon: <InventoryIcon />,
      requiresAuth: true,
    },
    {
      text: 'レシピ提案',
      path: '/recipes',
      icon: <RestaurantIcon />,
      requiresAuth: true,
    },
  ]

  const handleNavigation = (path: string) => {
    if (isAuthenticated) {
      navigate(path)
    } else {
      navigate('/login')
    }
  }

  return (
    <Box sx={{ display: 'flex', minHeight: '100vh' }}>
      {/* サイドバー */}
      <Drawer
        variant="permanent"
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
            bgcolor: '#1a1a1a',
            color: 'white',
          },
        }}
      >
        {/* ロゴ */}
        <Box
          sx={{
            p: 2,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: 64,
            borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
          }}
        >
          <Typography
            variant="h6"
            sx={{
              fontFamily: 'Outfit, sans-serif',
              fontWeight: 600,
              letterSpacing: '0.5px',
              color: 'white',
            }}
          >
            SMART PANTRY
          </Typography>
        </Box>

        {/* メニュー */}
        <List sx={{ mt: 2 }}>
          {menuItems.map((item) => (
            <ListItem key={item.text} disablePadding>
              <ListItemButton
                onClick={() => handleNavigation(item.path)}
                selected={location.pathname === item.path}
                sx={{
                  py: 1.5,
                  '&.Mui-selected': {
                    bgcolor: 'rgba(255, 255, 255, 0.08)',
                    '&:hover': {
                      bgcolor: 'rgba(255, 255, 255, 0.12)',
                    },
                  },
                  '&:hover': {
                    bgcolor: 'rgba(255, 255, 255, 0.04)',
                  },
                }}
              >
                <ListItemIcon sx={{ color: 'inherit', minWidth: 40 }}>
                  {item.icon}
                </ListItemIcon>
                <ListItemText
                  primary={item.text}
                  primaryTypographyProps={{
                    fontSize: '0.875rem',
                    fontWeight: location.pathname === item.path ? 500 : 400,
                  }}
                />
              </ListItemButton>
            </ListItem>
          ))}
        </List>
      </Drawer>

      {/* メインコンテンツ */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          bgcolor: '#f5f5f5',
          minHeight: '100vh',
        }}
      >
        {/* ヘッダー */}
        <AppBar
          position="fixed"
          sx={{
            width: `calc(100% - ${drawerWidth}px)`,
            ml: `${drawerWidth}px`,
            bgcolor: 'white',
            boxShadow: 'none',
            borderBottom: '1px solid rgba(0, 0, 0, 0.08)',
          }}
        >
          <Toolbar sx={{ justifyContent: 'flex-end' }}>
            <Button
              onClick={handleLogout}
              startIcon={<LogoutIcon />}
              sx={{
                color: 'text.secondary',
                textTransform: 'none',
                fontSize: '0.875rem',
                fontWeight: 500,
                '&:hover': {
                  bgcolor: 'rgba(0, 0, 0, 0.04)',
                },
              }}
            >
              ログアウト
            </Button>
          </Toolbar>
        </AppBar>

        {/* コンテンツ */}
        <Box sx={{ p: 3, mt: 8 }}>{children}</Box>
      </Box>
    </Box>
  )
}

================
File: react-todo/src/components/Navigation.tsx
================
import { FC } from 'react'
import { useMutateAuth } from '../hooks/useMutateAuth' // 修正
import { AppBar, Toolbar, Button, Box } from '@mui/material'
import { useNavigate, useLocation } from 'react-router-dom'
import RestaurantMenuIcon from '@mui/icons-material/RestaurantMenu'
import KitchenIcon from '@mui/icons-material/Kitchen'
import MenuBookIcon from '@mui/icons-material/MenuBook'

export const Navigation: FC = () => {
  const navigate = useNavigate()
  const location = useLocation()

  const { logoutMutation } = useMutateAuth()

  return (
    <AppBar position="static">
      <Toolbar>
        <Box sx={{ flexGrow: 1, display: 'flex', gap: 2 }}>
          <Button
            color="inherit"
            startIcon={<KitchenIcon />}
            onClick={() => navigate('/pantry')}
            sx={{
              borderBottom:
                location.pathname === '/pantry' ? '2px solid white' : 'none',
            }}
          >
            パントリー
          </Button>
          <Button
            color="inherit"
            startIcon={<RestaurantMenuIcon />}
            onClick={() => navigate('/food')}
            sx={{
              borderBottom:
                location.pathname === '/food' ? '2px solid white' : 'none',
            }}
          >
            食材管理
          </Button>
          <Button
            color="inherit"
            startIcon={<MenuBookIcon />}
            onClick={() => navigate('/recipes')}
            sx={{
              borderBottom:
                location.pathname === '/recipes' ? '2px solid white' : 'none',
            }}
          >
            レシピ提案
          </Button>
          <Button
            color="inherit"
            onClick={() => {
              logoutMutation.mutate() // ログアウト処理を呼び出す
            }}
          >
            ログアウト
          </Button>
        </Box>
      </Toolbar>
    </AppBar>
  )
}

================
File: react-todo/src/components/RecipeSuggestions.tsx
================
import { FC } from 'react'
import {
  Box,
  Card,
  CardContent,
  Typography,
  List,
  ListItem,
  ListItemText,
  CircularProgress,
  Container,
  Button,
  Chip,
} from '@mui/material'
import { useQueryFoodItems } from '../hooks/useQueryFoodItems'
import { useQueryRecipe } from '../hooks/useQueryRecipe'
import { FoodItem, Recipe } from '../types'
import ReactMarkdown from 'react-markdown'

export const RecipeSuggestions: FC = () => {
  const { data: foodItems, isLoading: isFoodLoading } = useQueryFoodItems()
  const {
    data: recipes,
    isLoading: isRecipeLoading,
    refetch,
    isFetching,
  } = useQueryRecipe()

  if (isFoodLoading || isRecipeLoading || isFetching) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    )
  }

  return (
    <Container maxWidth="md" sx={{ py: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        レシピ提案
      </Typography>

      <Box mb={4}>
        <Typography variant="h6" gutterBottom>
          現在の食材
        </Typography>
        <Card>
          <CardContent>
            <List>
              {foodItems && foodItems.length > 0 ? (
                foodItems.map((item: FoodItem) => {
                  const expiryDate = new Date(item.expiry_date)
                  const daysUntilExpiry = Math.ceil(
                    (expiryDate.getTime() - new Date().getTime()) /
                      (1000 * 3600 * 24)
                  )
                  const isExpiringSoon =
                    daysUntilExpiry >= 0 && daysUntilExpiry <= 7

                  return (
                    <ListItem
                      key={item.id}
                      sx={{
                        backgroundColor: isExpiringSoon
                          ? 'rgba(255, 193, 7, 0.1)'
                          : 'transparent',
                        borderLeft: isExpiringSoon
                          ? '4px solid #ffc107'
                          : 'none',
                      }}
                    >
                      <ListItemText
                        primary={
                          <Box
                            component="span"
                            sx={{ display: 'flex', alignItems: 'center' }}
                          >
                            {item.title}
                            {isExpiringSoon && (
                              <Typography
                                component="span"
                                sx={{
                                  ml: 1,
                                  fontSize: '0.8rem',
                                  color: 'warning.main',
                                  bgcolor: 'warning.light',
                                  px: 1,
                                  py: 0.5,
                                  borderRadius: 1,
                                }}
                              >
                                期限まであと{daysUntilExpiry}日
                              </Typography>
                            )}
                          </Box>
                        }
                        secondary={`残量: ${
                          item.quantity
                        } (期限: ${expiryDate.toLocaleDateString()})`}
                      />
                    </ListItem>
                  )
                })
              ) : (
                <ListItem>
                  <ListItemText
                    primary="食材が登録されていません"
                    secondary="食材を追加してレシピの提案を受けることができます"
                  />
                </ListItem>
              )}
            </List>
          </CardContent>
        </Card>
      </Box>

      <Box>
        <Box
          display="flex"
          justifyContent="space-between"
          alignItems="center"
          mb={2}
        >
          <Typography variant="h6">おすすめレシピ</Typography>
          <Button
            variant="contained"
            onClick={() => refetch()}
            disabled={isFetching}
          >
            レシピを更新
          </Button>
        </Box>
        <Card>
          <CardContent>
            <Box sx={{ mb: 2 }}>
              <Typography variant="body2" color="warning.main" sx={{ mb: 2 }}>
                ※
                賞味期限が7日以内の食材を優先的に使用したレシピを提案しています
              </Typography>
            </Box>
            {recipes && recipes.length > 0 ? (
              recipes.map((recipe: Recipe, index) => (
                <Box
                  key={recipe.id}
                  sx={{
                    mb: index < recipes.length - 1 ? 4 : 0,
                    pb: index < recipes.length - 1 ? 2 : 0,
                    borderBottom:
                      index < recipes.length - 1
                        ? '1px solid rgba(0, 0, 0, 0.12)'
                        : 'none',
                  }}
                >
                  <Typography variant="h6" gutterBottom>
                    {recipe.title}
                  </Typography>
                  <Box sx={{ mb: 2 }}>
                    {recipe.ingredients.map((ingredient, idx) => (
                      <Chip
                        key={idx}
                        label={ingredient}
                        sx={{ mr: 1, mb: 1 }}
                        variant="outlined"
                      />
                    ))}
                  </Box>
                  <ReactMarkdown className="markdown-body">
                    {recipe.instructions}
                  </ReactMarkdown>
                </Box>
              ))
            ) : (
              <Typography variant="body1" color="text.secondary" align="center">
                現在おすすめのレシピはありません。
                <br />
                食材を追加するか、「レシピを更新」ボタンをクリックしてください。
              </Typography>
            )}
          </CardContent>
        </Card>
      </Box>
    </Container>
  )
}

================
File: react-todo/src/components/TaskItem.tsx
================
import { FC, memo } from 'react'
import { PencilIcon, TrashIcon } from '@heroicons/react/24/solid'
import useStore from '../store'
import { Task } from '../types'
import { useMutateTask } from '../hooks/useMutateTask'

interface TaskItemProps extends Omit<Task, 'created_at' | 'updated_at'> {}

const TaskItemMemo: FC<TaskItemProps> = ({ id, title }) => {
  const updateTask = useStore((state) => state.updateEditedTask)
  const { deleteTaskMutation } = useMutateTask()

  return (
    <li className="my-3">
      <span className="font-bold">{title}</span>
      <div className="flex float-right ml-20">
        <PencilIcon
          className="h-5 w-5 mx-1 text-blue-500 cursor-pointer"
          onClick={() => {
            updateTask({
              id,
              title,
            })
          }}
        />
        <TrashIcon
          className="h-5 w-5 text-blue-500 cursor-pointer"
          onClick={() => {
            deleteTaskMutation.mutate(id)
          }}
        />
      </div>
    </li>
  )
}

export const TaskItem = memo(TaskItemMemo)

================
File: react-todo/src/components/Todo.tsx
================
import { FormEvent } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import {
  ArrowRightOnRectangleIcon,
  ShieldCheckIcon,
} from '@heroicons/react/24/solid'
import useStore from '../store'
import { useQueryTasks } from '../hooks/useQueryTasks'
import { useMutateTask } from '../hooks/useMutateTask'
import { useMutateAuth } from '../hooks/useMutateAuth'
import { TaskItem } from './TaskItem'
import { Task } from '../types'

export const Todo = () => {
  const queryClient = useQueryClient()
  const { editedTask } = useStore()
  const updateTask = useStore((state) => state.updateEditedTask)
  const { data, isLoading } = useQueryTasks()
  const { createTaskMutation, updateTaskMutation } = useMutateTask()
  const { logoutMutation } = useMutateAuth()

  const submitTaskHandler = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (editedTask.id === 0) {
      createTaskMutation.mutate({
        title: editedTask.title,
      })
    } else {
      updateTaskMutation.mutate({
        id: editedTask.id,
        title: editedTask.title,
      })
    }
  }

  const logout = async () => {
    await logoutMutation.mutateAsync()
    queryClient.removeQueries({ queryKey: ['tasks'] })
  }

  return (
    <div className="flex justify-center items-center flex-col min-h-screen text-gray-600 font-mono">
      <div className="flex items-center my-3">
        <ShieldCheckIcon className="h-8 w-8 mr-3 text-indigo-500 cursor-pointer" />
        <span className="text-center text-3xl font-extrabold">
          Task Manager
        </span>
      </div>
      <ArrowRightOnRectangleIcon
        onClick={logout}
        className="h-6 w-6 my-6 text-blue-500 cursor-pointer"
      />
      <form onSubmit={submitTaskHandler}>
        <input
          className="mb-3 mr-3 px-3 py-2 border border-gray-300"
          placeholder="title ?"
          type="text"
          onChange={(e) => updateTask({ ...editedTask, title: e.target.value })}
          value={editedTask.title || ''}
        />
        <button
          className="disabled:opacity-40 mx-3 py-2 px-3 text-white bg-indigo-600 rounded"
          disabled={!editedTask.title}
        >
          {editedTask.id === 0 ? 'Create' : 'Update'}
        </button>
      </form>
      {isLoading ? (
        <p>Loading...</p>
      ) : (
        <ul className="my-5">
          {data &&
            data.map((task: Task) => (
              <TaskItem key={task.id} id={task.id} title={task.title} />
            ))}
        </ul>
      )}
    </div>
  )
}

================
File: react-todo/src/hooks/useAuth.ts
================
import { useState, useEffect } from 'react'
import axiosInstance from '../lib/axios'

export const useAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  const checkAuth = async () => {
    try {
      await axiosInstance.get('/verify-token')
      setIsAuthenticated(true)
    } catch (error) {
      console.error('Token verification failed:', error)
      setIsAuthenticated(false)
      window.dispatchEvent(new CustomEvent('unauthorized'))
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    // 初回認証チェック
    checkAuth()

    // 定期的な認証チェック（5分ごと）
    const interval = setInterval(checkAuth, 5 * 60 * 1000)

    const handleUnauthorized = () => {
      setIsAuthenticated(false)
      setIsLoading(false)
    }

    const handleLoginSuccess = () => {
      setIsAuthenticated(true)
      setIsLoading(false)
    }

    const handleLogoutSuccess = () => {
      setIsAuthenticated(false)
      setIsLoading(false)
    }

    window.addEventListener('unauthorized', handleUnauthorized)
    window.addEventListener('login-success', handleLoginSuccess)
    window.addEventListener('logout-success', handleLogoutSuccess)

    return () => {
      clearInterval(interval)
      window.removeEventListener('unauthorized', handleUnauthorized)
      window.removeEventListener('login-success', handleLoginSuccess)
      window.removeEventListener('logout-success', handleLogoutSuccess)
    }
  }, [])

  return { isAuthenticated, isLoading }
}

================
File: react-todo/src/hooks/useError.ts
================
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import useStore from '../store'
import axiosInstance from '../lib/axios'

export const useError = () => {
  const navigate = useNavigate()
  const resetEditedTask = useStore((state) => state.resetEditedTask)
  const [errorMessage, setErrorMessage] = useState<string>('')

  const getCsrfToken = async () => {
    try {
      const { data } = await axiosInstance.get('/csrf')
      if (data.csrf_token) {
        axiosInstance.defaults.headers.common['X-CSRF-Token'] = data.csrf_token
      }
    } catch (error) {
      console.error('Failed to get CSRF token:', error)
      setErrorMessage('サーバーとの通信に失敗しました')
    }
  }

  const switchErrorHandling = (msg: string) => {
    switch (msg) {
      case 'invalid csrf token':
        getCsrfToken()
        setErrorMessage('セッションが無効です。もう一度お試しください')
        break
      case 'invalid email or password':
        setErrorMessage('メールアドレスまたはパスワードが正しくありません')
        break
      case 'invalid or expired jwt':
        localStorage.removeItem('accessToken')
        setErrorMessage(
          'セッションの有効期限が切れました。再度ログインしてください'
        )
        resetEditedTask()
        navigate('/')
        break
      case 'missing or malformed jwt':
        localStorage.removeItem('accessToken')
        setErrorMessage('認証情報が無効です。再度ログインしてください')
        resetEditedTask()
        navigate('/')
        break
      case 'email already exists':
        setErrorMessage('このメールアドレスは既に登録されています')
        break
      case 'failed to create user':
        setErrorMessage('ユーザー登録に失敗しました')
        break
      case 'failed to generate token':
        setErrorMessage('ログインに失敗しました。もう一度お試しください')
        break
      case 'record not found':
        setErrorMessage('メールアドレスまたはパスワードが正しくありません')
        break
      default:
        setErrorMessage(msg)
    }
  }

  return { switchErrorHandling, errorMessage, setErrorMessage }
}

================
File: react-todo/src/hooks/useFoodItemForm.ts
================
import { useState, ChangeEvent, FormEvent } from 'react'
import { useMutateFoodItem } from './useMutateFoodItem'

/**
 * 食材フォームのカスタムフック
 *
 * このフックは以下の機能を提供します：
 * - フォームの状態管理（食材名、数量、賞味期限）
 * - 入力値のバリデーション
 * - フォーム送信処理
 * - フォームのリセット
 *
 * @returns フォームの状態と操作メソッド
 */
export const useFoodItemForm = () => {
  // フォームの状態
  const [title, setTitle] = useState('')
  const [quantity, setQuantity] = useState(1)
  const [expiryDate, setExpiryDate] = useState<Date | null>(new Date())

  // 食材作成のミューテーションを取得
  const { createFoodItemMutation } = useMutateFoodItem()

  /**
   * 食材名の変更ハンドラー
   * @param e 変更イベント
   */
  const handleTitleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value)
  }

  /**
   * 数量の変更ハンドラー
   * 数値以外の入力や1未満の値は無視されます
   * @param e 変更イベント
   */
  const handleQuantityChange = (e: ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value)
    if (!isNaN(value) && value >= 1) {
      setQuantity(value)
    }
  }

  /**
   * 賞味期限の変更ハンドラー
   * @param date 選択された日付
   */
  const handleExpiryDateChange = (date: Date | null) => {
    setExpiryDate(date)
  }

  /**
   * フォーム送信ハンドラー
   * バリデーションを行い、問題なければ食材を作成します
   * @param e 送信イベント
   */
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault()

    // バリデーション
    if (title.trim() === '' || !expiryDate) {
      return
    }

    // 食材の作成
    createFoodItemMutation.mutate({
      title: title.trim(),
      quantity,
      expiry_date: expiryDate.toISOString(), // Date型をISO文字列に変換
    })

    // フォームのリセット
    resetForm()
  }

  /**
   * フォームの状態をリセット
   */
  const resetForm = () => {
    setTitle('')
    setQuantity(1)
    setExpiryDate(new Date())
  }

  return {
    // 状態
    title,
    quantity,
    expiryDate,
    // ハンドラー
    handleTitleChange,
    handleQuantityChange,
    handleExpiryDateChange,
    handleSubmit,
  }
}

================
File: react-todo/src/hooks/useMutateAuth.ts
================
import { AxiosError, AxiosResponse } from 'axios'
import { useNavigate } from 'react-router-dom'
import { useMutation } from '@tanstack/react-query'
import useStore from '../store'
import { Credential } from '../types'
import { useError } from '../hooks/useError'
import axiosInstance, { getCsrfToken } from '../lib/axios'

interface ApiError {
  message: string
}

export const useMutateAuth = () => {
  const navigate = useNavigate()
  const resetEditedTask = useStore((state) => state.resetEditedTask)
  const { switchErrorHandling } = useError()

  const loginMutation = useMutation<
    AxiosResponse,
    AxiosError<ApiError>,
    Credential
  >({
    mutationFn: async (user: Credential) => {
      await getCsrfToken()
      return await axiosInstance.post('/login', user)
    },
    onSuccess: () => {
      window.dispatchEvent(new CustomEvent('login-success'))
      navigate('/pantry', { replace: true })
    },
    onError: (err: AxiosError<ApiError>) => {
      console.error('Login error:', err)
      if (err.response?.data.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('ログインに失敗しました')
      }
    },
  })

  const registerMutation = useMutation<
    AxiosResponse,
    AxiosError<ApiError>,
    Credential
  >({
    mutationFn: async (user: Credential) => {
      await getCsrfToken()
      return await axiosInstance.post('/signup', user)
    },
    onError: (err: AxiosError<ApiError>) => {
      if (err.response?.data.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('アカウント作成に失敗しました')
      }
    },
  })

  const logoutMutation = useMutation<AxiosResponse, AxiosError<ApiError>, void>(
    {
      mutationFn: async () => {
        await getCsrfToken()
        return await axiosInstance.post('/logout')
      },
      onSuccess: () => {
        window.dispatchEvent(new CustomEvent('logout-success'))
        resetEditedTask()
        navigate('/', { replace: true })
      },
      onError: (err: AxiosError<ApiError>) => {
        if (err.response?.data.message) {
          switchErrorHandling(err.response.data.message)
        } else {
          switchErrorHandling('ログアウトに失敗しました')
        }
      },
    }
  )

  return { loginMutation, registerMutation, logoutMutation }
}

================
File: react-todo/src/hooks/useMutateFoodItem.ts
================
import { AxiosError, AxiosResponse } from 'axios'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { FoodItem } from '../types'
import { useError } from './useError'
import axiosInstance, { getCsrfToken } from '../lib/axios'

/**
 * APIレスポンスの型定義
 */
interface ApiResponse {
  data: FoodItem
}

/**
 * APIエラーの型定義
 */
interface ApiError {
  message: string
}

/**
 * キャッシュ更新用のユーティリティ関数
 */
const updateFoodItemsCache = (
  queryClient: ReturnType<typeof useQueryClient>,
  updater: (prev: FoodItem[]) => FoodItem[]
) => {
  const previousFoodItems = queryClient.getQueryData<FoodItem[]>(['foodItems'])
  if (previousFoodItems) {
    queryClient.setQueryData(['foodItems'], updater(previousFoodItems))
  }
}

/**
 * エラーハンドリング用のユーティリティ関数
 */
const handleApiError = (
  err: AxiosError<ApiError>,
  defaultMessage: string,
  errorHandler: (message: string) => void
) => {
  const message = err.response?.data.message || defaultMessage
  errorHandler(message)
}

/**
 * 食材データの操作（作成・更新・削除）を管理するカスタムフック
 *
 * このフックは以下の機能を提供します：
 * - 食材の作成（createFoodItemMutation）
 * - 食材の更新（updateFoodItemMutation）
 * - 食材の削除（deleteFoodItemMutation）
 *
 * 各操作は自動的にキャッシュを更新し、エラーハンドリングを行います。
 */
export const useMutateFoodItem = () => {
  const queryClient = useQueryClient()
  const { switchErrorHandling } = useError()

  /**
   * 食材作成のミューテーション
   */
  const createFoodItemMutation = useMutation({
    mutationFn: async (foodItem: Omit<FoodItem, 'id'>) => {
      await getCsrfToken()
      return await axiosInstance.post<ApiResponse>('/food-items', foodItem)
    },
    onSuccess: (res: AxiosResponse<ApiResponse>) => {
      updateFoodItemsCache(queryClient, (prev) => [...prev, res.data.data])
    },
    onError: (err: AxiosError<ApiError>) => {
      handleApiError(err, '食材の作成に失敗しました', switchErrorHandling)
    },
  })

  /**
   * 食材更新のミューテーション
   */
  const updateFoodItemMutation = useMutation({
    mutationFn: async (foodItem: FoodItem) => {
      await getCsrfToken()
      return await axiosInstance.put<ApiResponse>(
        `/food-items/${foodItem.id}`,
        foodItem
      )
    },
    onSuccess: (res: AxiosResponse<ApiResponse>, variables: FoodItem) => {
      updateFoodItemsCache(queryClient, (prev) =>
        prev.map((item) => (item.id === variables.id ? res.data.data : item))
      )
    },
    onError: (err: AxiosError<ApiError>) => {
      handleApiError(err, '食材の更新に失敗しました', switchErrorHandling)
    },
  })

  /**
   * 食材削除のミューテーション
   */
  const deleteFoodItemMutation = useMutation({
    mutationFn: async (id: number) => {
      await getCsrfToken()
      return await axiosInstance.delete(`/food-items/${id}`)
    },
    onSuccess: (_, variables: number) => {
      updateFoodItemsCache(queryClient, (prev) =>
        prev.filter((item) => item.id !== variables)
      )
    },
    onError: (err: AxiosError<ApiError>) => {
      handleApiError(err, '食材の削除に失敗しました', switchErrorHandling)
    },
  })

  return {
    createFoodItemMutation,
    updateFoodItemMutation,
    deleteFoodItemMutation,
  }
}

================
File: react-todo/src/hooks/useMutateTask.ts
================
import { AxiosError, AxiosResponse } from 'axios'
import { useQueryClient, useMutation } from '@tanstack/react-query'
import { Task } from '../types'
import useStore from '../store'
import { useError } from '../hooks/useError'
import axiosInstance, { getCsrfToken } from '../lib/axios'

interface ApiError {
  message: string
}

export const useMutateTask = () => {
  const queryClient = useQueryClient()
  const { switchErrorHandling } = useError()
  const resetEditedTask = useStore((state) => state.resetEditedTask)

  const createTaskMutation = useMutation({
    mutationFn: async (
      task: Omit<Task, 'id' | 'created_at' | 'updated_at'>
    ) => {
      await getCsrfToken()
      return await axiosInstance.post<Task>('/tasks', task)
    },
    onSuccess: (res: AxiosResponse<Task>) => {
      const previousTasks = queryClient.getQueryData<Task[]>(['tasks'])
      if (previousTasks) {
        queryClient.setQueryData(['tasks'], [...previousTasks, res.data])
      }
      resetEditedTask()
    },
    onError: (err: AxiosError<ApiError>) => {
      if (err.response?.data.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('タスクの作成に失敗しました')
      }
    },
  })

  const updateTaskMutation = useMutation({
    mutationFn: async (task: Omit<Task, 'created_at' | 'updated_at'>) => {
      await getCsrfToken()
      return await axiosInstance.put<Task>(`/tasks/${task.id}`, {
        title: task.title,
      })
    },
    onSuccess: (res: AxiosResponse<Task>, variables) => {
      const previousTasks = queryClient.getQueryData<Task[]>(['tasks'])
      if (previousTasks) {
        queryClient.setQueryData<Task[]>(
          ['tasks'],
          previousTasks.map((task) =>
            task.id === variables.id ? res.data : task
          )
        )
      }
      resetEditedTask()
    },
    onError: (err: AxiosError<ApiError>) => {
      if (err.response?.data.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('タスクの更新に失敗しました')
      }
    },
  })

  const deleteTaskMutation = useMutation({
    mutationFn: async (id: number) => {
      await getCsrfToken()
      return await axiosInstance.delete(`/tasks/${id}`)
    },
    onSuccess: (_, variables) => {
      const previousTasks = queryClient.getQueryData<Task[]>(['tasks'])
      if (previousTasks) {
        queryClient.setQueryData<Task[]>(
          ['tasks'],
          previousTasks.filter((task) => task.id !== variables)
        )
      }
      resetEditedTask()
    },
    onError: (err: AxiosError<ApiError>) => {
      if (err.response?.data.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('タスクの削除に失敗しました')
      }
    },
  })

  return {
    createTaskMutation,
    updateTaskMutation,
    deleteTaskMutation,
  }
}

================
File: react-todo/src/hooks/useQueryFoodItems.ts
================
import { AxiosError } from 'axios'
import { useQuery } from '@tanstack/react-query'
import { FoodItem } from '../types'
import { useError } from './useError'
import axiosInstance from '../lib/axios'

export const useQueryFoodItems = () => {
  const { switchErrorHandling } = useError()

  const getFoodItems = async (): Promise<FoodItem[]> => {
    try {
      const { data } = await axiosInstance.get<FoodItem[]>('/food-items')
      if (!data) return []
      if (!Array.isArray(data)) {
        console.error('Received non-array data:', data)
        return []
      }
      return data
    } catch (err) {
      console.error('Failed to fetch food items:', err)
      if (err instanceof AxiosError && err.response?.data?.message) {
        switchErrorHandling(err.response.data.message)
      } else {
        switchErrorHandling('食材の取得に失敗しました')
      }
      return []
    }
  }

  return useQuery({
    queryKey: ['foodItems'],
    queryFn: getFoodItems,
    staleTime: 1000 * 60 * 5, // 5分
    initialData: [],
    retry: 1,
  })
}

================
File: react-todo/src/hooks/useQueryRecipe.ts
================
import { useQuery } from '@tanstack/react-query'
import axiosInstance from '../lib/axios'
import { Recipe } from '../types'

export const useQueryRecipe = () => {
  const getRecipes = async () => {
    try {
      const { data } = await axiosInstance.get<Recipe[]>('/recipes/suggestions')
      return data || []
    } catch (error) {
      console.error('Failed to fetch recipes:', error)
      return []
    }
  }

  return useQuery({
    queryKey: ['recipes'],
    queryFn: getRecipes,
    staleTime: 1000 * 60 * 5,
    initialData: [],
    retry: 1,
  })
}

================
File: react-todo/src/hooks/useQueryTasks.ts
================
import { AxiosError } from 'axios'
import { useError } from './useError'
import { useQuery } from '@tanstack/react-query'
import { Task } from '../types'
import axiosInstance, { getCsrfToken } from '../lib/axios'

interface ApiError {
  message: string
}

export const useQueryTasks = () => {
  const { switchErrorHandling } = useError()

  const getTasks = async () => {
    try {
      await getCsrfToken()
      const { data } = await axiosInstance.get<Task[]>('/tasks', {
        withCredentials: true,
      })
      return data
    } catch (err) {
      if (err instanceof AxiosError) {
        const axiosError = err as AxiosError<ApiError>
        if (axiosError.response?.data.message) {
          switchErrorHandling(axiosError.response.data.message)
        } else {
          switchErrorHandling('タスクの取得に失敗しました')
        }
      }
      throw err
    }
  }

  return useQuery({
    queryKey: ['tasks'],
    queryFn: getTasks,
    staleTime: Infinity,
  })
}

================
File: react-todo/src/lib/axios.ts
================
import axios from 'axios'

const axiosInstance = axios.create({
  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8080',
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
})

// リクエストインターセプターを追加
axiosInstance.interceptors.request.use(
  (config) => {
    // CSRFトークンがある場合は設定
    const csrfToken = axiosInstance.defaults.headers.common['X-CSRF-Token']
    if (csrfToken) {
      config.headers['X-CSRF-Token'] = csrfToken
    }

    // cookieベースの認証を使用するため、ここでの追加のトークン設定は不要

    return config
  },
  (error) => {
    console.error('Request error:', error)
    return Promise.reject(error)
  }
)

// レスポンスインターセプターを追加
axiosInstance.interceptors.response.use(
  (response) => {
    return response
  },
  async (error) => {
    console.error('Response error:', error)

    // ネットワークエラーの場合
    if (!error.response) {
      window.dispatchEvent(
        new CustomEvent('error', {
          detail: 'サーバーとの通信に失敗しました',
        })
      )
      return Promise.reject(error)
    }

    // 認証エラーの場合
    if (error.response.status === 401) {
      window.dispatchEvent(new CustomEvent('unauthorized'))
    }

    // CSRFエラーの場合
    if (error.response.data?.message?.includes('csrf')) {
      try {
        await getCsrfToken()
        // 元のリクエストを再試行
        const config = error.config
        return axiosInstance(config)
      } catch (retryError) {
        console.error('CSRF retry failed:', retryError)
      }
    }

    return Promise.reject(error)
  }
)

export const getCsrfToken = async () => {
  try {
    const { data } = await axiosInstance.get('/csrf')
    if (data.csrf_token) {
      axiosInstance.defaults.headers.common['X-CSRF-Token'] = data.csrf_token
    } else {
      console.error('No CSRF token in response')
    }
  } catch (error) {
    console.error('Failed to get CSRF token:', error)
    throw error
  }
}

export default axiosInstance

================
File: react-todo/src/pages/PantryPage.tsx
================
import React, { FC } from 'react'
import { useNavigate } from 'react-router-dom'
import { useQueryClient } from '@tanstack/react-query'
import { useQueryFoodItems } from '../hooks/useQueryFoodItems'
import { useQueryRecipe } from '../hooks/useQueryRecipe'
import { Typography, Box, Grid, Paper, CircularProgress } from '@mui/material'
import { Recipe } from '../types'

export const PantryPage: FC = () => {
  const navigate = useNavigate()
  const queryClient = useQueryClient()
  const { data: foodItems = [], isLoading: isFoodLoading } = useQueryFoodItems()
  const { data: recipes = [], isLoading: isRecipeLoading } = useQueryRecipe()

  // 日数計算用のヘルパー関数
  const getDaysUntilExpiry = (expiryDateStr: string): number => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const expiry = new Date(expiryDateStr)
    expiry.setHours(0, 0, 0, 0)
    return Math.ceil((expiry.getTime() - today.getTime()) / (1000 * 3600 * 24))
  }

  // 期限切れ食材を抽出
  const expiredItems = foodItems.filter((item) => {
    if (!item?.expiry_date) return false
    try {
      return getDaysUntilExpiry(item.expiry_date) < 0
    } catch (e) {
      console.error('Invalid date:', item.expiry_date)
      return false
    }
  })

  // 期限切れが近い食材（7日以内）を抽出
  const nearExpiryItems = foodItems.filter((item) => {
    if (!item?.expiry_date) return false
    try {
      const daysUntilExpiry = getDaysUntilExpiry(item.expiry_date)
      return daysUntilExpiry <= 7 && daysUntilExpiry >= 0
    } catch (e) {
      console.error('Invalid date:', item.expiry_date)
      return false
    }
  })

  // 残量が少ない食材を抽出
  const lowStockItems = foodItems.filter(
    (item) => item?.quantity && item.quantity <= 2
  )

  // 日付をフォーマットする関数
  const formatDate = (dateStr: string): string => {
    try {
      return new Date(dateStr).toLocaleDateString('ja-JP')
    } catch (e) {
      console.error('Invalid date:', dateStr)
      return '無効な日付'
    }
  }

  if (isFoodLoading || isRecipeLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="80vh"
      >
        <CircularProgress />
      </Box>
    )
  }

  return (
    <Box>
      {/* ページタイトル */}
      <Typography
        variant="h5"
        sx={{
          mb: 4,
          fontWeight: 600,
          color: '#1a1a1a',
          position: 'relative',
          '&::after': {
            content: '""',
            position: 'absolute',
            bottom: -8,
            left: 0,
            width: 40,
            height: 3,
            background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',
            borderRadius: '2px',
          },
        }}
      >
        パントリー管理
      </Typography>

      <Grid container spacing={3}>
        {/* 期限切れ食材 */}
        <Grid item xs={12} md={6}>
          <Paper
            elevation={0}
            sx={{
              p: 3,
              height: '100%',
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)',
              border: '1px solid rgba(0, 0, 0, 0.08)',
              position: 'relative',
              overflow: 'hidden',
              transition: 'transform 0.2s ease-in-out',
              '&:hover': {
                transform: 'translateY(-2px)',
              },
            }}
          >
            <Typography
              variant="h6"
              sx={{
                mb: 3,
                fontWeight: 600,
                color: 'error.main',
                display: 'flex',
                alignItems: 'center',
                gap: 1,
              }}
            >
              期限切れの食材
            </Typography>
            {expiredItems.length > 0 ? (
              <Box>
                {expiredItems.map((item) => (
                  <Box
                    key={item.id}
                    sx={{
                      p: 2,
                      mb: 2,
                      borderRadius: 1,
                      bgcolor: 'rgba(255, 255, 255, 0.8)',
                      border: '1px solid rgba(0, 0, 0, 0.04)',
                      '&:last-child': {
                        mb: 0,
                      },
                    }}
                  >
                    <Typography sx={{ fontWeight: 500 }}>
                      {item.title}
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{
                        color: 'text.secondary',
                        mt: 0.5,
                      }}
                    >
                      期限: {formatDate(item.expiry_date)}
                    </Typography>
                  </Box>
                ))}
              </Box>
            ) : (
              <Typography
                variant="body2"
                sx={{
                  color: 'text.secondary',
                  fontStyle: 'italic',
                }}
              >
                期限切れの食材はありません
              </Typography>
            )}
          </Paper>
        </Grid>

        {/* 期限切れ間近の食材 */}
        <Grid item xs={12} md={6}>
          <Paper
            elevation={0}
            sx={{
              p: 3,
              height: '100%',
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)',
              border: '1px solid rgba(0, 0, 0, 0.08)',
              position: 'relative',
              overflow: 'hidden',
              transition: 'transform 0.2s ease-in-out',
              '&:hover': {
                transform: 'translateY(-2px)',
              },
            }}
          >
            <Typography
              variant="h6"
              sx={{
                mb: 3,
                fontWeight: 600,
                color: 'warning.main',
                display: 'flex',
                alignItems: 'center',
                gap: 1,
              }}
            >
              期限切れ間近の食材
            </Typography>
            {nearExpiryItems.length > 0 ? (
              <Box>
                {nearExpiryItems.map((item) => (
                  <Box
                    key={item.id}
                    sx={{
                      p: 2,
                      mb: 2,
                      borderRadius: 1,
                      bgcolor: 'rgba(255, 255, 255, 0.8)',
                      border: '1px solid rgba(0, 0, 0, 0.04)',
                      '&:last-child': {
                        mb: 0,
                      },
                    }}
                  >
                    <Typography sx={{ fontWeight: 500 }}>
                      {item.title}
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{
                        color: 'text.secondary',
                        mt: 0.5,
                      }}
                    >
                      期限: {formatDate(item.expiry_date)}
                    </Typography>
                  </Box>
                ))}
              </Box>
            ) : (
              <Typography
                variant="body2"
                sx={{
                  color: 'text.secondary',
                  fontStyle: 'italic',
                }}
              >
                期限切れが近い食材はありません
              </Typography>
            )}
          </Paper>
        </Grid>

        {/* 在庫状況 */}
        <Grid item xs={12} md={6}>
          <Paper
            elevation={0}
            sx={{
              p: 3,
              height: '100%',
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)',
              border: '1px solid rgba(0, 0, 0, 0.08)',
              position: 'relative',
              overflow: 'hidden',
              transition: 'transform 0.2s ease-in-out',
              '&:hover': {
                transform: 'translateY(-2px)',
              },
            }}
          >
            <Typography
              variant="h6"
              sx={{
                mb: 3,
                fontWeight: 600,
                color: 'info.main',
                display: 'flex',
                alignItems: 'center',
                gap: 1,
              }}
            >
              在庫状況
            </Typography>
            {lowStockItems.length > 0 ? (
              <Box>
                {lowStockItems.map((item) => (
                  <Box
                    key={item.id}
                    sx={{
                      p: 2,
                      mb: 2,
                      borderRadius: 1,
                      bgcolor: 'rgba(255, 255, 255, 0.8)',
                      border: '1px solid rgba(0, 0, 0, 0.04)',
                      '&:last-child': {
                        mb: 0,
                      },
                    }}
                  >
                    <Typography sx={{ fontWeight: 500 }}>
                      {item.title}
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{
                        color: 'text.secondary',
                        mt: 0.5,
                      }}
                    >
                      残量: {item.quantity}個
                    </Typography>
                  </Box>
                ))}
              </Box>
            ) : (
              <Typography
                variant="body2"
                sx={{
                  color: 'text.secondary',
                  fontStyle: 'italic',
                }}
              >
                在庫が少ない食材はありません
              </Typography>
            )}
          </Paper>
        </Grid>

        {/* おすすめレシピ */}
        <Grid item xs={12}>
          <Paper
            elevation={0}
            sx={{
              p: 3,
              borderRadius: 2,
              background: 'linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%)',
              border: '1px solid rgba(0, 0, 0, 0.08)',
              position: 'relative',
              overflow: 'hidden',
              transition: 'transform 0.2s ease-in-out',
              '&:hover': {
                transform: 'translateY(-2px)',
              },
            }}
          >
            <Typography
              variant="h6"
              sx={{
                mb: 3,
                fontWeight: 600,
                color: 'success.main',
                display: 'flex',
                alignItems: 'center',
                gap: 1,
              }}
            >
              今日のおすすめレシピ
            </Typography>
            {recipes.length > 0 ? (
              <Box>
                {recipes.slice(0, 3).map((recipe: Recipe, index) => (
                  <Box
                    key={index}
                    sx={{
                      p: 2,
                      mb: 2,
                      borderRadius: 1,
                      bgcolor: 'rgba(255, 255, 255, 0.8)',
                      border: '1px solid rgba(0, 0, 0, 0.04)',
                      '&:last-child': {
                        mb: 0,
                      },
                    }}
                  >
                    <Typography sx={{ fontWeight: 500 }}>
                      {recipe.title}
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{
                        color: 'text.secondary',
                        mt: 0.5,
                      }}
                    >
                      使用食材: {recipe.ingredients?.join(', ') || '情報なし'}
                    </Typography>
                  </Box>
                ))}
              </Box>
            ) : (
              <Typography
                variant="body2"
                sx={{
                  color: 'text.secondary',
                  fontStyle: 'italic',
                }}
              >
                現在おすすめできるレシピはありません
              </Typography>
            )}
          </Paper>
        </Grid>
      </Grid>
    </Box>
  )
}

================
File: react-todo/src/store/index.ts
================
import { create } from 'zustand'

type EditedTask = {
  id: number
  title: string
}

type State = {
  editedTask: EditedTask
  updateEditedTask: (payload: EditedTask) => void
  resetEditedTask: () => void
}

const useStore = create<State>((set) => ({
  editedTask: { id: 0, title: '' },
  updateEditedTask: (payload) =>
    set({
      editedTask: payload,
    }),
  resetEditedTask: () => set({ editedTask: { id: 0, title: '' } }),
}))

export default useStore

================
File: react-todo/src/types/index.ts
================
export type Task = {
  id: number
  title: string
  created_at: Date
  updated_at: Date
}

export type Credential = {
  email: string
  password: string
}

export type User = {
  id: number
  email: string
  created_at: Date
  updated_at: Date
}

export type CsrfToken = {
  csrf_token: string
}

export type FoodItem = {
  id: number
  title: string
  quantity: number
  expiry_date: string // Date型から文字列型に変更
  created_at?: string // 同様に文字列型に変更
  updated_at?: string // 同様に文字列型に変更
  user_id?: number
}

export type Recipe = {
  id: number
  title: string
  ingredients: string[]
  instructions: string
  created_at?: string // 同様に文字列型に変更
  updated_at?: string // 同様に文字列型に変更
}

export type EditedTask = {
  id: number
  title: string
}

================
File: react-todo/src/App.tsx
================
import React, { FC } from 'react'
import {
  BrowserRouter,
  Routes,
  Route,
  Navigate,
  Outlet,
  useNavigate,
} from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { Auth } from './components/Auth'
import { Layout } from './components/Layout'
import { PantryPage } from './pages/PantryPage'
import { FoodList } from './components/FoodList'
import { RecipeSuggestions } from './components/RecipeSuggestions'
import { useAuth } from './hooks/useAuth'
import { CircularProgress, Box } from '@mui/material'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      refetchOnWindowFocus: false,
    },
  },
})

const AuthListener: FC = () => {
  const navigate = useNavigate()

  React.useEffect(() => {
    const handleUnauthorized = () => {
      navigate('/', { replace: true })
    }

    window.addEventListener('unauthorized', handleUnauthorized)
    return () => {
      window.removeEventListener('unauthorized', handleUnauthorized)
    }
  }, [navigate])

  return null
}

const LoadingSpinner: FC = () => (
  <Box
    sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100vh',
    }}
  >
    <CircularProgress />
  </Box>
)

const ProtectedRoute: FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth()

  if (isLoading) {
    return <LoadingSpinner />
  }

  if (!isAuthenticated) {
    return <Navigate to="/" replace />
  }

  return <>{children}</>
}

const AppRoutes: FC = () => {
  const { isAuthenticated, isLoading } = useAuth()

  if (isLoading) {
    return <LoadingSpinner />
  }

  return (
    <Routes>
      {/* 認証ページ */}
      <Route
        path="/"
        element={isAuthenticated ? <Navigate to="/pantry" replace /> : <Auth />}
      />

      {/* 認証が必要なページ */}
      <Route
        element={
          <ProtectedRoute>
            <Layout>
              <Outlet />
            </Layout>
          </ProtectedRoute>
        }
      >
        {/* パントリー管理 */}
        <Route path="/pantry" element={<PantryPage />} />

        {/* 食材管理 */}
        <Route path="/food" element={<FoodList />} />

        {/* レシピ提案 */}
        <Route path="/recipes" element={<RecipeSuggestions />} />

        {/* 404ページ */}
        <Route path="*" element={<Navigate to="/pantry" replace />} />
      </Route>
    </Routes>
  )
}

const App: FC = () => {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <AuthListener />
        <AppRoutes />
      </BrowserRouter>
    </QueryClientProvider>
  )
}

export default App

================
File: react-todo/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

.markdown-body {
  @apply text-base leading-relaxed;
  background-color: transparent !important;
  color: inherit !important;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  @apply font-bold mb-4 mt-6;
  border-bottom: none !important;
}

.markdown-body h1 {
  @apply text-2xl;
}

.markdown-body h2 {
  @apply text-xl;
}

.markdown-body h3 {
  @apply text-lg;
}

.markdown-body p {
  @apply mb-4;
}

.markdown-body ul,
.markdown-body ol {
  @apply mb-4 pl-6;
}

.markdown-body li {
  @apply mb-2;
}

.markdown-body code {
  @apply bg-gray-100 px-1 py-0.5 rounded text-sm;
}

.markdown-body pre {
  @apply bg-gray-100 p-4 rounded mb-4 overflow-x-auto;
}

.markdown-body blockquote {
  @apply border-l-4 border-gray-300 pl-4 italic my-4;
}

.markdown-body hr {
  @apply my-6 border-t border-gray-200;
}

.markdown-body table {
  @apply w-full mb-4 border-collapse;
}

.markdown-body th,
.markdown-body td {
  @apply border border-gray-300 p-2;
}

.markdown-body th {
  @apply bg-gray-100;
}

================
File: react-todo/src/index.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App'
import reportWebVitals from './reportWebVitals'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import 'github-markdown-css'

const queryClient = new QueryClient({})

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)
root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>
)

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals()

================
File: react-todo/src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: react-todo/src/react-app-env.d.ts
================
/// <reference types="react-scripts" />

================
File: react-todo/src/reportWebVitals.ts
================
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: react-todo/src/setupTests.ts
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom'

// Mock the environment variables
process.env.REACT_APP_API_URL = 'http://localhost:8080'

// Mock the IntersectionObserver
const mockIntersectionObserver = jest.fn()
mockIntersectionObserver.mockReturnValue({
  observe: () => null,
  unobserve: () => null,
  disconnect: () => null,
})
window.IntersectionObserver = mockIntersectionObserver

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // deprecated
    removeListener: jest.fn(), // deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
})

================
File: react-todo/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

================
File: react-todo/.prettierrc
================
{
  "singleQuote": true,
  "semi": false
}

================
File: react-todo/package.json
================
{
  "name": "react-todo",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@heroicons/react": "^2.2.0",
    "@mui/icons-material": "^5.15.7",
    "@mui/material": "^5.16.14",
    "@mui/x-date-pickers": "^6.20.2",
    "@tanstack/react-query": "^5.18.1",
    "@tanstack/react-query-devtools": "^5.18.1",
    "@types/node": "^16.18.79",
    "@types/react": "^18.2.52",
    "@types/react-dom": "^18.2.18",
    "axios": "^1.6.7",
    "date-fns": "^2.30.0",
    "github-markdown-css": "^5.8.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^9.0.3",
    "react-router-dom": "^6.22.0",
    "react-scripts": "5.0.1",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4",
    "zustand": "^5.0.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.1",
    "@testing-library/react": "^14.2.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.12"
  }
}

================
File: react-todo/README.md
================
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

================
File: react-todo/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: react-todo/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

================
File: .env.example
================
# バックエンド設定
PORT=8080
POSTGRES_USER=postgres
POSTGRES_PW=postgres
POSTGRES_DB=smart_pantry
POSTGRES_PORT=5432
POSTGRES_HOST=localhost
API_DOMAIN=localhost
SECRET=your-secret-key

# Gemini API設定
GEMINI_API_KEY=your-gemini-api-key

# フロントエンド設定
REACT_APP_API_URL=http://localhost:8080

================
File: .gitignore
================
# Go
/bin/
/pkg/
/vendor/

# Node
/node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# React
/build/
/coverage/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDEs and editors
/.vscode/
/.idea/
/*.suo
/*.ntvs*
/*.njsproj
/*.sln

# OS files
.DS_Store
Thumbs.db
frontend/node_modules

================
File: README.md
================
# Smart Pantry

食材管理とレシピ提案を行う Web アプリケーション

## 機能

1. 食材管理

   - 食材の登録・編集・削除
   - 数量管理
   - 賞味期限管理

2. 賞味期限トラッカー

   - 期限切れ間近の食材を自動検出
   - 視覚的なアラート表示（黄色：期限間近、赤：期限切れ）

3. AI レシピ提案
   - 期限切れ間近の食材を活用したレシピを自動提案
   - 栄養バランスを考慮したレシピ生成
   - 5 分ごとに自動更新

## セットアップ手順

### 1. 環境変数の設定

`.env`ファイルを作成し、以下の環境変数を設定：

```bash
cp .env.example .env
```

```env
# バックエンド設定
PORT=8080
POSTGRES_USER=postgres
POSTGRES_PW=postgres
POSTGRES_DB=smart_pantry
POSTGRES_PORT=5432
POSTGRES_HOST=localhost
API_DOMAIN=localhost
SECRET=your-secret-key

# Gemini API設定
GEMINI_API_KEY=your-gemini-api-key
```

### 2. Gemini API キーの取得

1. [Google Cloud Console](https://console.cloud.google.com/)にアクセス
2. プロジェクトを作成（または既存のプロジェクトを選択）
3. [API とサービス] > [認証情報]に移動
4. [認証情報を作成] > [API キー]を選択
5. 作成された API キーを`.env`の`GEMINI_API_KEY`にコピー

### 3. データベースのセットアップ

PostgreSQL を Docker で起動：

```bash
cd go-rest-api
docker-compose up -d
```

マイグレーションの実行：

```bash
go run migrate/migrate.go
```

### 4. バックエンドの起動

```bash
cd go-rest-api
go mod download
go run main.go
```

### 5. フロントエンドの起動

```bash
cd react-todo
npm install
npm start
```

## 開発環境

### バックエンド

- Go 1.23.5
- Echo Framework
- GORM
- PostgreSQL 15
- Google Gemini API

### フロントエンド

- React 18
- TypeScript 4.9
- Material-UI 5
- React Query
- date-fns

## データベース構造

### FoodItems テーブル

```sql
CREATE TABLE food_items (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    quantity INTEGER NOT NULL,
    expiry_date TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
);
```

### Users テーブル

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## API エンドポイント

### 認証

- POST `/signup`: ユーザー登録
- POST `/login`: ログイン
- POST `/logout`: ログアウト
- GET `/csrf`: CSRF トークン取得

### 食材管理

- GET `/food-items`: 食材一覧の取得
- GET `/food-items/:id`: 特定の食材の取得
- POST `/food-items`: 新規食材の登録
- PUT `/food-items/:id`: 食材情報の更新
- DELETE `/food-items/:id`: 食材の削除

### レシピ提案

- GET `/recipes/suggestions`: AI によるレシピ提案の取得

## テスト実行

```bash
# バックエンドのテスト
cd go-rest-api
go test ./...

# フロントエンドのテスト
cd react-todo
npm test
```

## 注意事項

- 賞味期限が 7 日以内の食材に対してアラートが表示されます
- レシピ提案は期限切れ間近の食材を優先的に使用します
- API リクエストには JWT 認証が必要です
- Gemini API の利用には課金が発生する可能性があります
